{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"Caseum Caseum is a simple approach to software architecture that combines multiple views to boost understanding and empathy across roles. Video introduction Watch on YouTube Multiple views Caseum combines these views: C omponents using C4 A ctors using roles S tories using Gherkin E vents using event storming U I using wireframes M odels using TLM Together these views fully describe a software system. Not all projects need all views. Lightweight approach Caseum is for doing just enough architecture. It has three stages: whiteboarding & dialogue digital diagrams & decision records models as code & executable specifications Not all projects need all stages. See the guide on stages of architecture . See the guide on as-is and to-be designs for working on existing projects. Recording decisions Architecture records the important design decisions for a system. The records are for communicating with current and future people working on and with the software. See the guide on recording decisions . Tools The primary tools used by Caseum are: Whiteboards, markers, and sticky notes Draw.io for digital diagrams Markdown text files for decision records Model specification in structured text formats (Structurizr C4, Gherkin, TLMD and AsyncAPI JSON) See the guides on whiteboarding architecture and on using draw.io for architecture . Different tools are available per view per stage: Whiteboarding & Dialogue Diagrams & Decision Records Models & Executable Specifications Components Boxes & lines C4 Draw.io Library C4 as Code Actors Roles & needs Role Markdown Template - Stories Goals & epics User Story Markdown Template Gherkin Events Event Storming ES Draw.io Library AsyncAPI UI Boxes & lines Wireframes Draw.io Library - Models Circles & lines TLM Draw.io Library TLMD License Caseum by Leo Simons is licensed under a Creative Commons Attribution 4.0 International License . See LICENSE.txt for a plain text copy of the Creative Commons Attribution 4.0 International License. Contributing See CONTRIBUTING.md for details on how to contribute to Caseum. Code of conduct See Code of Conduct for details on how to participate in the Caseum community.","title":"Home"},{"location":"index.html#caseum","text":"Caseum is a simple approach to software architecture that combines multiple views to boost understanding and empathy across roles.","title":"Caseum"},{"location":"index.html#video-introduction","text":"Watch on YouTube","title":"Video introduction"},{"location":"index.html#multiple-views","text":"Caseum combines these views: C omponents using C4 A ctors using roles S tories using Gherkin E vents using event storming U I using wireframes M odels using TLM Together these views fully describe a software system. Not all projects need all views.","title":"Multiple views"},{"location":"index.html#lightweight-approach","text":"Caseum is for doing just enough architecture. It has three stages: whiteboarding & dialogue digital diagrams & decision records models as code & executable specifications Not all projects need all stages. See the guide on stages of architecture . See the guide on as-is and to-be designs for working on existing projects.","title":"Lightweight approach"},{"location":"index.html#recording-decisions","text":"Architecture records the important design decisions for a system. The records are for communicating with current and future people working on and with the software. See the guide on recording decisions .","title":"Recording decisions"},{"location":"index.html#tools","text":"The primary tools used by Caseum are: Whiteboards, markers, and sticky notes Draw.io for digital diagrams Markdown text files for decision records Model specification in structured text formats (Structurizr C4, Gherkin, TLMD and AsyncAPI JSON) See the guides on whiteboarding architecture and on using draw.io for architecture . Different tools are available per view per stage: Whiteboarding & Dialogue Diagrams & Decision Records Models & Executable Specifications Components Boxes & lines C4 Draw.io Library C4 as Code Actors Roles & needs Role Markdown Template - Stories Goals & epics User Story Markdown Template Gherkin Events Event Storming ES Draw.io Library AsyncAPI UI Boxes & lines Wireframes Draw.io Library - Models Circles & lines TLM Draw.io Library TLMD","title":"Tools"},{"location":"index.html#license","text":"Caseum by Leo Simons is licensed under a Creative Commons Attribution 4.0 International License . See LICENSE.txt for a plain text copy of the Creative Commons Attribution 4.0 International License.","title":"License"},{"location":"index.html#contributing","text":"See CONTRIBUTING.md for details on how to contribute to Caseum.","title":"Contributing"},{"location":"index.html#code-of-conduct","text":"See Code of Conduct for details on how to participate in the Caseum community.","title":"Code of conduct"},{"location":"CODE_OF_CONDUCT.html","text":"Code of Conduct Our Goal We aim to make participation in our community a harassment-free experience for everyone. We aim to act and interact in ways that contribute to an open, welcoming, diverse, inclusive, and healthy community. Our Standards Examples of behavior that contributes to a positive environment for our community include: Demonstrating empathy and kindness toward other people Being respectful of differing opinions, viewpoints, and experiences Giving and gracefully accepting constructive feedback Accepting responsibility and apologizing to those affected by our mistakes, and learning from the experience Focusing on what is best not just for us as individuals, but for the overall community Any conduct which could reasonably be considered inappropriate in a professional setting is unacceptable. Moderation Community leaders should take appropriate and fair corrective action in response to any behavior that they deem inappropriate, threatening, offensive, or harmful. Community leaders have the ability to remove or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, and should communicate reasons for moderation decisions when appropriate. Scope This Code of Conduct applies within all community spaces, and also applies when an individual is officially representing the community in public spaces. Enforcement Instances of abusive, harassing, or otherwise unacceptable behavior may be reported to @lsimons. Complaints will be reviewed and investigated. Enforcement Guidelines Community leaders will follow these Community Impact Guidelines in determining the consequences for any action they deem in violation of this Code of Conduct: 1. Correction Community Impact : Use of inappropriate language or other behavior deemed unprofessional or unwelcome in the community. Consequence : A warning from community leaders, providing clarity around the nature of the violation and an explanation of why the behavior was inappropriate. 2. Warning Community Impact : A violation through a single incident or series of actions. Consequence : A warning with consequences for continued behavior. No interaction with the people involved for a specified period of time. 3. Temporary Ban Community Impact : A serious violation of community standards, including sustained inappropriate behavior. Consequence : A temporary ban from any sort of interaction or public communication with the community for a specified period of time. No public or private interaction with the people involved is allowed during this period. Violating these terms may lead to a permanent ban. 4. Permanent Ban Community Impact : Demonstrating a pattern of violation of community standards, including sustained inappropriate behavior, harassment of an individual, or aggression toward or disparagement of classes of individuals. Consequence : A permanent ban from any sort of public interaction within the community. Attribution This Code of Conduct is adapted from the Contributor Covenant, version 2.0, available at https://www.contributor-covenant.org/version/2/0/code_of_conduct.html. Community Impact Guidelines were inspired by Mozilla's code of conduct enforcement ladder .","title":"Code of conduct"},{"location":"CODE_OF_CONDUCT.html#code-of-conduct","text":"","title":"Code of Conduct"},{"location":"CODE_OF_CONDUCT.html#our-goal","text":"We aim to make participation in our community a harassment-free experience for everyone. We aim to act and interact in ways that contribute to an open, welcoming, diverse, inclusive, and healthy community.","title":"Our Goal"},{"location":"CODE_OF_CONDUCT.html#our-standards","text":"Examples of behavior that contributes to a positive environment for our community include: Demonstrating empathy and kindness toward other people Being respectful of differing opinions, viewpoints, and experiences Giving and gracefully accepting constructive feedback Accepting responsibility and apologizing to those affected by our mistakes, and learning from the experience Focusing on what is best not just for us as individuals, but for the overall community Any conduct which could reasonably be considered inappropriate in a professional setting is unacceptable.","title":"Our Standards"},{"location":"CODE_OF_CONDUCT.html#moderation","text":"Community leaders should take appropriate and fair corrective action in response to any behavior that they deem inappropriate, threatening, offensive, or harmful. Community leaders have the ability to remove or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, and should communicate reasons for moderation decisions when appropriate.","title":"Moderation"},{"location":"CODE_OF_CONDUCT.html#scope","text":"This Code of Conduct applies within all community spaces, and also applies when an individual is officially representing the community in public spaces.","title":"Scope"},{"location":"CODE_OF_CONDUCT.html#enforcement","text":"Instances of abusive, harassing, or otherwise unacceptable behavior may be reported to @lsimons. Complaints will be reviewed and investigated.","title":"Enforcement"},{"location":"CODE_OF_CONDUCT.html#enforcement-guidelines","text":"Community leaders will follow these Community Impact Guidelines in determining the consequences for any action they deem in violation of this Code of Conduct:","title":"Enforcement Guidelines"},{"location":"CODE_OF_CONDUCT.html#1-correction","text":"Community Impact : Use of inappropriate language or other behavior deemed unprofessional or unwelcome in the community. Consequence : A warning from community leaders, providing clarity around the nature of the violation and an explanation of why the behavior was inappropriate.","title":"1. Correction"},{"location":"CODE_OF_CONDUCT.html#2-warning","text":"Community Impact : A violation through a single incident or series of actions. Consequence : A warning with consequences for continued behavior. No interaction with the people involved for a specified period of time.","title":"2. Warning"},{"location":"CODE_OF_CONDUCT.html#3-temporary-ban","text":"Community Impact : A serious violation of community standards, including sustained inappropriate behavior. Consequence : A temporary ban from any sort of interaction or public communication with the community for a specified period of time. No public or private interaction with the people involved is allowed during this period. Violating these terms may lead to a permanent ban.","title":"3. Temporary Ban"},{"location":"CODE_OF_CONDUCT.html#4-permanent-ban","text":"Community Impact : Demonstrating a pattern of violation of community standards, including sustained inappropriate behavior, harassment of an individual, or aggression toward or disparagement of classes of individuals. Consequence : A permanent ban from any sort of public interaction within the community.","title":"4. Permanent Ban"},{"location":"CODE_OF_CONDUCT.html#attribution","text":"This Code of Conduct is adapted from the Contributor Covenant, version 2.0, available at https://www.contributor-covenant.org/version/2/0/code_of_conduct.html. Community Impact Guidelines were inspired by Mozilla's code of conduct enforcement ladder .","title":"Attribution"},{"location":"CONTRIBUTING.html","text":"Thank you for investing your time in contributing to our project! Any contributions you make are governed by our License . Please follow our Code of Conduct to keep our community approachable and respectable. You could read the GitHub Docs Contributing Guide for general advice on how to contribute. Since this is a small hobby project, your contribution may not be noticed for a while if we are busy elsewhere. Sorry! MkDocs This site is built with MkDocs . That's a python tool. Python is managed with uv . Run uv sync to install the dependencies. Then: uv run publish_index.py - Sync over some files. uv run mkdocs serve - Start the live-reloading docs server. uv run mkdocs build - Build the documentation site.","title":"Contributing to Caseum"},{"location":"CONTRIBUTING.html#mkdocs","text":"This site is built with MkDocs . That's a python tool. Python is managed with uv . Run uv sync to install the dependencies. Then: uv run publish_index.py - Sync over some files. uv run mkdocs serve - Start the live-reloading docs server. uv run mkdocs build - Build the documentation site.","title":"MkDocs"},{"location":"actors/actor-whiteboarding.html","text":"Whiteboarding actors Always consider a system's customers, users, and stakeholders. Also consider external systems that connect to the system. Together, these are the actors . When designing software only used by other systems, consider the customers, users, and stakeholders of those systems. When designing software it helps to always keep these actors in mind, so in most views it helps to always draw them and to draw them first. Rather than design the system for a generic user, be clear about which users use the system. If you have followed an approach like design thinking you may already have a clear description of the human actors, which you can just summarize for use in Caseum. In other cases, it may be quite hard to become clear about which actors the system is for. This can be the case, for example, if stakeholders disagree! If so, that hard work must happen before other designs are made. Basic actors For human actors, capture at least: role name : the descriptive label of the role of this actor in the wider context in which the software system is used. need : what actors in this role need to accomplish that they use the software system for. For non-human actors, capture at least: category name : a descriptive label that applies to all similar software systems that use the system. purpose : why the external system is connecting to this system. You don't have to capture all the non-human actors, only the important ones that you specifically design for. For example, when designing a website, you often don't need to draw the web browsers users will use to access the site. Draw each actor with an icon. See this FontAwesome collection of users for some icons you might try to draw, but don't get too fancy: it's important to keep them simple so you and others working on the design can draw them easily and similarly many times. A simple way to draw an actor is as a circle for their head with a rectangle just underneath it for their upper torso. Then, write their role underneath to make clear which actor it is. Non-actors It can help to be clear about people that are close to the software system who do not interact with the software system themselves. You might write them down and then mark them as not actors. For example, a software system in a hospital may be very patient-centric but not ever used by the patients themselves, instead only being accessible by the medical staff. Bad actors It can sometimes help to be clear about people who should not interact with the software system but will try to do so anyway. This is especially important if the software is a security system or if security is a major feature of the system. For systems where the security is \"standard\" or handled \"in some standard way\", do not include these actors in the main view. Instead, you may later draw some specific security views that have these bad actors included. User-centric design vs actors In user experience design, empathy maps describe users' pains and gains, what they think and say and do and feel. Similarly, user experience designers may define fictional characters called personas that help the designer imagine what to create. These are quite a valuable research and design tool. But such empathy maps and personas are not part of Caseum and not quite the same as an actor description. From these user-centric designs, distill a more generic (cold, clear, clean, factual) role description for use in the creation of the software architecture. You might link these together with a few statements such as \"User {name} has the role {role} while working with {software system}\". Using color Draw the actors in blue and their needs in green. Draw any non-actors in black. Draw any bad actors in red.","title":"Actor whiteboarding"},{"location":"actors/actor-whiteboarding.html#whiteboarding-actors","text":"Always consider a system's customers, users, and stakeholders. Also consider external systems that connect to the system. Together, these are the actors . When designing software only used by other systems, consider the customers, users, and stakeholders of those systems. When designing software it helps to always keep these actors in mind, so in most views it helps to always draw them and to draw them first. Rather than design the system for a generic user, be clear about which users use the system. If you have followed an approach like design thinking you may already have a clear description of the human actors, which you can just summarize for use in Caseum. In other cases, it may be quite hard to become clear about which actors the system is for. This can be the case, for example, if stakeholders disagree! If so, that hard work must happen before other designs are made.","title":"Whiteboarding actors"},{"location":"actors/actor-whiteboarding.html#basic-actors","text":"For human actors, capture at least: role name : the descriptive label of the role of this actor in the wider context in which the software system is used. need : what actors in this role need to accomplish that they use the software system for. For non-human actors, capture at least: category name : a descriptive label that applies to all similar software systems that use the system. purpose : why the external system is connecting to this system. You don't have to capture all the non-human actors, only the important ones that you specifically design for. For example, when designing a website, you often don't need to draw the web browsers users will use to access the site. Draw each actor with an icon. See this FontAwesome collection of users for some icons you might try to draw, but don't get too fancy: it's important to keep them simple so you and others working on the design can draw them easily and similarly many times. A simple way to draw an actor is as a circle for their head with a rectangle just underneath it for their upper torso. Then, write their role underneath to make clear which actor it is.","title":"Basic actors"},{"location":"actors/actor-whiteboarding.html#non-actors","text":"It can help to be clear about people that are close to the software system who do not interact with the software system themselves. You might write them down and then mark them as not actors. For example, a software system in a hospital may be very patient-centric but not ever used by the patients themselves, instead only being accessible by the medical staff.","title":"Non-actors"},{"location":"actors/actor-whiteboarding.html#bad-actors","text":"It can sometimes help to be clear about people who should not interact with the software system but will try to do so anyway. This is especially important if the software is a security system or if security is a major feature of the system. For systems where the security is \"standard\" or handled \"in some standard way\", do not include these actors in the main view. Instead, you may later draw some specific security views that have these bad actors included.","title":"Bad actors"},{"location":"actors/actor-whiteboarding.html#user-centric-design-vs-actors","text":"In user experience design, empathy maps describe users' pains and gains, what they think and say and do and feel. Similarly, user experience designers may define fictional characters called personas that help the designer imagine what to create. These are quite a valuable research and design tool. But such empathy maps and personas are not part of Caseum and not quite the same as an actor description. From these user-centric designs, distill a more generic (cold, clear, clean, factual) role description for use in the creation of the software architecture. You might link these together with a few statements such as \"User {name} has the role {role} while working with {software system}\".","title":"User-centric design vs actors"},{"location":"actors/actor-whiteboarding.html#using-color","text":"Draw the actors in blue and their needs in green. Draw any non-actors in black. Draw any bad actors in red.","title":"Using color"},{"location":"actors/role-template.html","text":"Describing actors with a role description Keep a short, clear list of actor role descriptions. Caseum is for designing a software system, not the organization that uses the system. Keep descriptions of actors simple: do not model the human structure of the organization in great detail. Role description markdown template Here's a markdown template for capturing roles: <img alt=\"icon for an actor\" src=\"https://raw.githubusercontent.com/FortAwesome/Font-Awesome/6.x/svgs/solid/user.svg\" width=\"30\" align=\"left\" style=\"margin-right: 20px\"> ### Role: {role name} {Short role description.} **Goals and needs:** {short goals and needs description.} **Responsibilities:** * {Short responsibility description #1.} * {Short responsibility description #2.} * {Short responsibility description #3.} Do not write a complete list of goals, needs and responsibilities. Focus only on the information that influences how they will use the software, plus perhaps some basic info that helps everyone understand the nature of the role. Role examples Here are some example role descriptions: Role: veterinarian Medical professional who cares for animals at the Pet Clinic. \"Vet\" for short. Goals and needs: Needs to take care of pets that visit the Pet Clinic. Also needs to talk to the pet owner during such visits. Wants to have an optimal schedule of appointments and to be prepared for those appointments. Responsibilities: * Check their appointment schedule * Look up key information before or during an appointment * Save key medical information about a pet during or right after an appointment Role: pet clinic receptionist Professional with an administrative support role in the Pet Clinic. \"Receptionist\" for short. Goals and needs: Needs to ensure the smooth running of the Pet Clinic. Wants to welcome pet owners and their pets and support the vet in their work, for which they manage the Pet Clinic schedule. Responsibilities: * Answer the phone * Welcome pet owners and pets during visits * Manage the appointment schedule * Plan and re-plan appointments * Remind pet owners of upcoming appointments * Schedule recurring check-in appointments Role: pet owner (non-actor) Pet owners interact with the receptionist and the vet but not the Pet Clinic admin system. Goals and needs: Needs to take care of their pet.","title":"Role template"},{"location":"actors/role-template.html#describing-actors-with-a-role-description","text":"Keep a short, clear list of actor role descriptions. Caseum is for designing a software system, not the organization that uses the system. Keep descriptions of actors simple: do not model the human structure of the organization in great detail.","title":"Describing actors with a role description"},{"location":"actors/role-template.html#role-description-markdown-template","text":"Here's a markdown template for capturing roles: <img alt=\"icon for an actor\" src=\"https://raw.githubusercontent.com/FortAwesome/Font-Awesome/6.x/svgs/solid/user.svg\" width=\"30\" align=\"left\" style=\"margin-right: 20px\"> ### Role: {role name} {Short role description.} **Goals and needs:** {short goals and needs description.} **Responsibilities:** * {Short responsibility description #1.} * {Short responsibility description #2.} * {Short responsibility description #3.} Do not write a complete list of goals, needs and responsibilities. Focus only on the information that influences how they will use the software, plus perhaps some basic info that helps everyone understand the nature of the role.","title":"Role description markdown template"},{"location":"actors/role-template.html#role-examples","text":"Here are some example role descriptions:","title":"Role examples"},{"location":"actors/role-template.html#role-veterinarian","text":"Medical professional who cares for animals at the Pet Clinic. \"Vet\" for short. Goals and needs: Needs to take care of pets that visit the Pet Clinic. Also needs to talk to the pet owner during such visits. Wants to have an optimal schedule of appointments and to be prepared for those appointments. Responsibilities: * Check their appointment schedule * Look up key information before or during an appointment * Save key medical information about a pet during or right after an appointment","title":"Role: veterinarian"},{"location":"actors/role-template.html#role-pet-clinic-receptionist","text":"Professional with an administrative support role in the Pet Clinic. \"Receptionist\" for short. Goals and needs: Needs to ensure the smooth running of the Pet Clinic. Wants to welcome pet owners and their pets and support the vet in their work, for which they manage the Pet Clinic schedule. Responsibilities: * Answer the phone * Welcome pet owners and pets during visits * Manage the appointment schedule * Plan and re-plan appointments * Remind pet owners of upcoming appointments * Schedule recurring check-in appointments","title":"Role: pet clinic receptionist"},{"location":"actors/role-template.html#role-pet-owner-non-actor","text":"Pet owners interact with the receptionist and the vet but not the Pet Clinic admin system. Goals and needs: Needs to take care of their pet.","title":"Role: pet owner (non-actor)"},{"location":"components/c4-code.html","text":"Modeling components in code using C4 and Structurizr Use Structurizr to model the components of your system in code. C4 is perhaps the most popular way to describe the component architecture of software and Caseum adopts it. When using C4 models-as-code, Caseum uses Structurizr. Structurizr supports using custom styles to match the Caseum color scheme: workspace { model { ... } views { ... styles { element \"Software System\" { background #122A59 color #ffffff } element \"Container\" { background #29467F color #ffffff } ... } } } Here's an example C4 model you can paste into the Structurizr DSL to get started: workspace { model { receptionist = person \"Pet Clinic Receptionist\" \"Plans appointments and welcomes visitors\" { } petClinic = softwareSystem \"Pet Clinic\" \"Administers the pet clinic.\" { customersDb = container \"Customers DB\" \"\" \"SQLite DB\" db vetsDb = container \"Vets DB\" \"\" \"SQLite DB\" db appointmentsDb = container \"Appointments DB\" \"\" \"SQLite DB\" db customersSvc = container \"Customers Service\" \"\" \"Spring Boot App\" microservice { -> customersDb \"Manages customers\" \"SQL\" } vetsSvc = container \"Vets Service\" \"\" \"Spring Boot App\" microservice { -> vetsDb \"Manages vets\" \"SQL\" } appointmentsSvc = container \"Appointments Service\" \"\" \"Spring Boot App\" microservice { -> appointmentsDb \"Manages appointments\" \"SQL\" } adminUI = container \"Pet Clinic Admin UI\" \"\" \"Angular.js Application\" webapp { -> customersSvc \"Manages customers\" \"REST\" -> vetsSvc \"Manages vets\" \"REST\" -> appointmentsSvc \"Manages appointments\" \"REST\" } } receptionist -> adminUI \"Manages pet clinic\" \"HTTPS\" } views { systemContext petClinic PetClinicContext { include * autoLayout } container petClinic PetClinicContainer { include * autoLayout } styles { element \"Software System\" { background #122A59 color #ffffff } element \"Container\" { background #29467F color #ffffff } element \"microservice\" { shape Hexagon } element \"db\" { shape Cylinder } element \"Person\" { shape person background #122A59 color #ffffff } } } } Keep it accessible Note that while the C4 website recommends using models as code, Caseum recommends using a whiteboard initially and for as long as possible, and to also consider digital diagrams before making models using code.","title":"Component architecture-as-code"},{"location":"components/c4-code.html#modeling-components-in-code-using-c4-and-structurizr","text":"Use Structurizr to model the components of your system in code. C4 is perhaps the most popular way to describe the component architecture of software and Caseum adopts it. When using C4 models-as-code, Caseum uses Structurizr. Structurizr supports using custom styles to match the Caseum color scheme: workspace { model { ... } views { ... styles { element \"Software System\" { background #122A59 color #ffffff } element \"Container\" { background #29467F color #ffffff } ... } } } Here's an example C4 model you can paste into the Structurizr DSL to get started: workspace { model { receptionist = person \"Pet Clinic Receptionist\" \"Plans appointments and welcomes visitors\" { } petClinic = softwareSystem \"Pet Clinic\" \"Administers the pet clinic.\" { customersDb = container \"Customers DB\" \"\" \"SQLite DB\" db vetsDb = container \"Vets DB\" \"\" \"SQLite DB\" db appointmentsDb = container \"Appointments DB\" \"\" \"SQLite DB\" db customersSvc = container \"Customers Service\" \"\" \"Spring Boot App\" microservice { -> customersDb \"Manages customers\" \"SQL\" } vetsSvc = container \"Vets Service\" \"\" \"Spring Boot App\" microservice { -> vetsDb \"Manages vets\" \"SQL\" } appointmentsSvc = container \"Appointments Service\" \"\" \"Spring Boot App\" microservice { -> appointmentsDb \"Manages appointments\" \"SQL\" } adminUI = container \"Pet Clinic Admin UI\" \"\" \"Angular.js Application\" webapp { -> customersSvc \"Manages customers\" \"REST\" -> vetsSvc \"Manages vets\" \"REST\" -> appointmentsSvc \"Manages appointments\" \"REST\" } } receptionist -> adminUI \"Manages pet clinic\" \"HTTPS\" } views { systemContext petClinic PetClinicContext { include * autoLayout } container petClinic PetClinicContainer { include * autoLayout } styles { element \"Software System\" { background #122A59 color #ffffff } element \"Container\" { background #29467F color #ffffff } element \"microservice\" { shape Hexagon } element \"db\" { shape Cylinder } element \"Person\" { shape person background #122A59 color #ffffff } } } }","title":"Modeling components in code using C4 and Structurizr"},{"location":"components/c4-code.html#keep-it-accessible","text":"Note that while the C4 website recommends using models as code, Caseum recommends using a whiteboard initially and for as long as possible, and to also consider digital diagrams before making models using code.","title":"Keep it accessible"},{"location":"components/c4-template.html","text":"Describing components with C4 diagrams Use C4 diagrams to describe the components of your system. C4 is perhaps the most popular way to describe the component architecture of software and Caseum adopts it. For digital C4 diagrams, Caseum uses draw.io. Draw.io supports C4 diagrams natively with a Shape library that you can use. You can also use these drawing tools to match the Caseum color scheme: Caseum-C4.xml : a draw.io modified C4 shape library with C4 elements using the Caseum colors . User guide . C4.drawio : a draw.io stencil containing the elements in the custom shape library. Keep it accessible Note that while the C4 website recommends using models as code , Caseum recommends using a whiteboard initially and for as long as possible, and to also consider digital diagrams before making models using code.","title":"Component template"},{"location":"components/c4-template.html#describing-components-with-c4-diagrams","text":"Use C4 diagrams to describe the components of your system. C4 is perhaps the most popular way to describe the component architecture of software and Caseum adopts it. For digital C4 diagrams, Caseum uses draw.io. Draw.io supports C4 diagrams natively with a Shape library that you can use. You can also use these drawing tools to match the Caseum color scheme: Caseum-C4.xml : a draw.io modified C4 shape library with C4 elements using the Caseum colors . User guide . C4.drawio : a draw.io stencil containing the elements in the custom shape library.","title":"Describing components with C4 diagrams"},{"location":"components/c4-template.html#keep-it-accessible","text":"Note that while the C4 website recommends using models as code , Caseum recommends using a whiteboard initially and for as long as possible, and to also consider digital diagrams before making models using code.","title":"Keep it accessible"},{"location":"components/c4-whiteboarding.html","text":"Whiteboarding components with C4 diagrams Use C4-style diagrams to draw the components of your system on a whiteboard. It isn't important to follow the C4 model exactly. Focus on the story you want to tell with your diagrams. Context Diagram The context diagram is the highest-level diagram in C4. It shows the software system in context of its environment. Do not skip the context diagram when drawing architecture on the whiteboard. The context diagram grounds the architecture story in the business context. It connects the actors and stories to the component architecture. If you don't know where to start, follow this process: First, draw the actors, at the top of the whiteboard. Next, draw the software systems in the middle of the whiteboard. Then, draw the connections between the actors and the software systems. Avoid drawing system boundaries on the whiteboard, they clutter the board. Container Diagram When designing small systems you can skip the container diagram initially. The container diagram connects the C4 context to the C4 components. It shows the high-level parts of the software system and how they connect. If you don't know where to start, follow this process: First, draw the actors, at the top of the whiteboard. Next, draw any databases or other low-level containers at the bottom of the whiteboard. Then, draw the sofware systems in the middle of the whiteboard. Finally, draw the connections between the actors and the software systems and between the software systems and the databases. Component Diagram The component diagram is the lowest-level C4 diagram to draw on a whiteboard. It shows all the software components that make up a (sub)system and how they connect together. The component diagram is often most useful to developers while deciding how to implement a system, while it can be too detailed for other stakeholders. When drawing the component diagram on the whiteboard, focus on the components that are most important to the story you are telling. You don't need to add the full details of all components in the system. If you skipped making the container diagram, once there are more components to a system than can fit on one whiteboard, go back and summarize the component diagram as a container diagram. Keep it accessible Note that while the C4 website recommends using models as code , Caseum recommends using a whiteboard initially and for as long as possible, and to also consider digital diagrams before making models using code. Avoid drawing huge diagrams on whiteboards C4 originally defined only Context, Container, Component, and Class Diagrams (with the last one auto-generated from code, not hand-drawn). It has since added some other diagram types such as the system landscape diagram and the deployment diagram. You tend to need these once your system gets larger or more complex, at which point it often also makes sense to switch from whiteboarding to digital diagrams . Don't focus too much on components Many users of C4 use the component-based view as their only or at least their dominant view. Caseum recommends also using all the other views. Some designs are best detailed using events , while others are best modelled using facts .","title":"Component whiteboarding"},{"location":"components/c4-whiteboarding.html#whiteboarding-components-with-c4-diagrams","text":"Use C4-style diagrams to draw the components of your system on a whiteboard. It isn't important to follow the C4 model exactly. Focus on the story you want to tell with your diagrams.","title":"Whiteboarding components with C4 diagrams"},{"location":"components/c4-whiteboarding.html#context-diagram","text":"The context diagram is the highest-level diagram in C4. It shows the software system in context of its environment. Do not skip the context diagram when drawing architecture on the whiteboard. The context diagram grounds the architecture story in the business context. It connects the actors and stories to the component architecture. If you don't know where to start, follow this process: First, draw the actors, at the top of the whiteboard. Next, draw the software systems in the middle of the whiteboard. Then, draw the connections between the actors and the software systems. Avoid drawing system boundaries on the whiteboard, they clutter the board.","title":"Context Diagram"},{"location":"components/c4-whiteboarding.html#container-diagram","text":"When designing small systems you can skip the container diagram initially. The container diagram connects the C4 context to the C4 components. It shows the high-level parts of the software system and how they connect. If you don't know where to start, follow this process: First, draw the actors, at the top of the whiteboard. Next, draw any databases or other low-level containers at the bottom of the whiteboard. Then, draw the sofware systems in the middle of the whiteboard. Finally, draw the connections between the actors and the software systems and between the software systems and the databases.","title":"Container Diagram"},{"location":"components/c4-whiteboarding.html#component-diagram","text":"The component diagram is the lowest-level C4 diagram to draw on a whiteboard. It shows all the software components that make up a (sub)system and how they connect together. The component diagram is often most useful to developers while deciding how to implement a system, while it can be too detailed for other stakeholders. When drawing the component diagram on the whiteboard, focus on the components that are most important to the story you are telling. You don't need to add the full details of all components in the system. If you skipped making the container diagram, once there are more components to a system than can fit on one whiteboard, go back and summarize the component diagram as a container diagram.","title":"Component Diagram"},{"location":"components/c4-whiteboarding.html#keep-it-accessible","text":"Note that while the C4 website recommends using models as code , Caseum recommends using a whiteboard initially and for as long as possible, and to also consider digital diagrams before making models using code.","title":"Keep it accessible"},{"location":"components/c4-whiteboarding.html#avoid-drawing-huge-diagrams-on-whiteboards","text":"C4 originally defined only Context, Container, Component, and Class Diagrams (with the last one auto-generated from code, not hand-drawn). It has since added some other diagram types such as the system landscape diagram and the deployment diagram. You tend to need these once your system gets larger or more complex, at which point it often also makes sense to switch from whiteboarding to digital diagrams .","title":"Avoid drawing huge diagrams on whiteboards"},{"location":"components/c4-whiteboarding.html#dont-focus-too-much-on-components","text":"Many users of C4 use the component-based view as their only or at least their dominant view. Caseum recommends also using all the other views. Some designs are best detailed using events , while others are best modelled using facts .","title":"Don't focus too much on components"},{"location":"design/fonts.html","text":"Long-form: Merriweather On-screen: Merriweather Sans Monospace: Cascadia Code Wireframe: Architects Daughter","title":"Caseum fonts"},{"location":"design/colors/colors.html","text":"Caseum uses the following color scheme: Color usage Black: text (on white or light background), lines White: text (against main colors and dark colors) Main: Blue: primary Green: secondary Brown: tertiary Magenta: highlight/alert Grey: faded/background/disabled/external Dark colors: special/focus Light colors: accent/background/selection/grouping Color numbers main Blue: #29467F \u2014 (41,70,128) Green: #3C6320 \u2014 (60.99,32) Magenta: #7F294B \u2014 (128,41,75) Brown: #7F5529 \u2014 (127,85,41) dark Dark Blue: #122A59 \u2014 (18,42,89) Dark Green: #213D0C \u2014 (33,61,12) Dark Magenta: #59122E \u2014 (89,18,46) Dark Brown: #593612 \u2014 (89,54,18) light Light Blue: #8B98B2 \u2014 (139,152,178) Light Green: #A1B28B \u2014 (161,178,139) Light Magenta: #B28B9B \u2014 (178,139,155) Light Brown: #B29F8B \u2014 (178,159,139) grayscale Black: #000000 \u2014 (0,0,0) Dark Grey: #595959 \u2014 (89,89,89) Grey: #808080 \u2014 (128,128,128) Light Grey: #B2B2B2 \u2014 (178,178,178) White: #FFFFFF \u2014 (255,255,255) Background These colors are all high-contrast vs black or white (7:1 or more), ranking them as AAA according to WCAG accessibility guidelines. The colors are selected to be somewhat distinguishable by most people with most kinds of color blindness. The colors are selected to align closely to black+RGB which are common whiteboard marker colors, which helps when transcribing whiteboard drawings. Red is avoided since it can mean different things across cultures, and is most commonly difficult to distinguish for the color-blind. The colors are selected to look \"ok\" on screen and in print, even when printed using grayscale. The colors are selected to be bold and distinguishable. The main blue color is chosen to have the same hue as the blue used in C4 diagrams, though with a higher contrast. This makes combined Caseum/C4 diagrams look \"ok\".","title":"Caseum colors"},{"location":"design/colors/colors.html#color-usage","text":"Black: text (on white or light background), lines White: text (against main colors and dark colors) Main: Blue: primary Green: secondary Brown: tertiary Magenta: highlight/alert Grey: faded/background/disabled/external Dark colors: special/focus Light colors: accent/background/selection/grouping","title":"Color usage"},{"location":"design/colors/colors.html#color-numbers","text":"main Blue: #29467F \u2014 (41,70,128) Green: #3C6320 \u2014 (60.99,32) Magenta: #7F294B \u2014 (128,41,75) Brown: #7F5529 \u2014 (127,85,41) dark Dark Blue: #122A59 \u2014 (18,42,89) Dark Green: #213D0C \u2014 (33,61,12) Dark Magenta: #59122E \u2014 (89,18,46) Dark Brown: #593612 \u2014 (89,54,18) light Light Blue: #8B98B2 \u2014 (139,152,178) Light Green: #A1B28B \u2014 (161,178,139) Light Magenta: #B28B9B \u2014 (178,139,155) Light Brown: #B29F8B \u2014 (178,159,139) grayscale Black: #000000 \u2014 (0,0,0) Dark Grey: #595959 \u2014 (89,89,89) Grey: #808080 \u2014 (128,128,128) Light Grey: #B2B2B2 \u2014 (178,178,178) White: #FFFFFF \u2014 (255,255,255)","title":"Color numbers"},{"location":"design/colors/colors.html#background","text":"These colors are all high-contrast vs black or white (7:1 or more), ranking them as AAA according to WCAG accessibility guidelines. The colors are selected to be somewhat distinguishable by most people with most kinds of color blindness. The colors are selected to align closely to black+RGB which are common whiteboard marker colors, which helps when transcribing whiteboard drawings. Red is avoided since it can mean different things across cultures, and is most commonly difficult to distinguish for the color-blind. The colors are selected to look \"ok\" on screen and in print, even when printed using grayscale. The colors are selected to be bold and distinguishable. The main blue color is chosen to have the same hue as the blue used in C4 diagrams, though with a higher contrast. This makes combined Caseum/C4 diagrams look \"ok\".","title":"Background"},{"location":"events/asyncapi-code.html","text":"Modeling events in code using AsyncAPI Use a specification based on JSON Schema to model the events of your system in code. For an event-heavy system use the AsyncAPI specification . For a system with mostly RESTful APIs, use the OpenAPI specification instead. Which JSON Schema specification is best? JSON Schema is a modern schema language that is used to define the structure of JSON documents. JSON Schema is embedded in the widely adopted OpenAPI specification to define the structure of RESTful APIs. The somewhat newer AsyncAPI specification is a lot like OpenAPI, but with specific support for event-driven systems. Which standard should you use? In mid-2023, if your architecture is mostly based on services and their interactions, go with OpenAPI, since it has more tooling support and is more widely used. If instead you have many asynchronous interactions in your system, or many of the interactions are multi-producer or multi-subscriber, then AsyncAPI is a better choice. XML Schema The most powerful schema language in common use today for modeling entity representations in APIs is XML Schema. XML Schema is used by SOAP, the Simple Object Access Protocol, which really is not simple. SOAP also has other problems. SOAP was popular 15 years ago but is not popular today. Perhaps in part because of this, XML Schema and XML are also less popular. If you must interface with XML-based systems you might adopt XML Schema in addition to JSON Schema. As of late 2022 the best way to convert between XML Schema and JSON Schema is the commercial product Altova XMLSpy , which may be worth investing if you have to maintain schemas with 50 elements or more. Model mapping is a chore If you use domain models and fact-based modeling that effort can form the basis of the entity definitions in your JSON Schema. In this case your OpenAPI or AsyncAPI specifications can import those entity definitions. This approach works well for medium-size systems. You probably won't have such models-as-code for small systems since those don't need models-as-code architecture. As mentioned in the Guide on stages , actively try to avoid over-engineering small systems. On the other end, for large systems that are worked on by multiple teams in parallel you need loose coupling between subsystems so the teams can work somewhat independently. In this case you need to decouple the domain model for a subsystem from the event/API representations of the entities that are communicated with that subsystem. You then end up with significant duplication in architecture and implementation, and ongoing effort to maintain a mapping between internal models and external event specifications. There is no perfect way to avoid this mapping effort. There are many approaches to creating and maintaining model mappings. Caseum makes no recommendations on this topic, beyond the general advice to plan for it deliberately and to then record the design decisions you take on it. Alternatives to JSON Schema These are reasonable alternatives worth considering: OData is more prescriptive. If it fits your needs then you can use the OData tooling ecosystem and get functionality for free. OData is used by Microsoft Azure, Dynamics, and Office 365. While it is an open standard with many implementations, the best OData tool support is in the Microsoft ecosystem, specifically in .Net and Visual Studio. GraphQL is a powerful approach to create flexible APIs that are just right for the consumer of that API. This is often worth the investment when building user interfaces, especially mobile applications. For very large systems you may have GraphQL APIs between frontend and backend systems, and OpenAPI or AsyncAPI schemas for use among backend systems. Apache Avro , Apache Thrift , GRPC with Protocol Buffers , Cap'n Proto , ZeroMQ with ABNF , or one of many other such more specific technology choices. If one of these is the right choice for your application, and you define a schema for it, avoid duplicating those schema definitions in JSON Schema. Alternatives to using an open standard You can work without any standard or schema for your event definitions. This may couple your architecture to a specific (commercial) technology. That is not always bad! For example it may save you significant time and effort and result in a simpler and smaller solution. Many architects and developers intuitively don't like such choices, since they are afraid of the loss of flexibility. Making this tradeoff is an important architecture choice. So, take some time to make this decision and record it. Choosing between open standards and proprietary technology is not all-or-nothing. For example, you can map schemas in architecture but not in code. Specific commercial technology may come with its own reasonable schema language. For example, TIBCO BusinessWorks uses a proprietary schema language for its XML-based message formats. You can use the TIBCO schema language for your event definitions, and then use tooling to convert between TIBCO schema and JSON Schema. You still tie most of your system to the TIBCO schema and protocol. You do have a route toward interoperability by introducing adapters to JSON Schema if that becomes important. Industry standards should influence architecture choices The choice of schema language can depend on the business domain you are working in. There are various industries with extensive standard schema definitions and these are often worth using. For example, the HL7 v3 and CDA standards for healthcare data exchange are based on XML Schema. These standards and probably more widely deployed in 2023 than the newer HL7 FHIR which supports JSON Schema. In other domains, JSON and XML are not appropriate technology and then it makes no sense to use their schema languages. For example, if you work on an automotive system using the CAN bus , messages may defined at a lower protocol layer. In such a case you stick to using a text description of the messages instead of a schema language.","title":"AsyncAPI specs-as-code"},{"location":"events/asyncapi-code.html#modeling-events-in-code-using-asyncapi","text":"Use a specification based on JSON Schema to model the events of your system in code. For an event-heavy system use the AsyncAPI specification . For a system with mostly RESTful APIs, use the OpenAPI specification instead.","title":"Modeling events in code using AsyncAPI"},{"location":"events/asyncapi-code.html#which-json-schema-specification-is-best","text":"JSON Schema is a modern schema language that is used to define the structure of JSON documents. JSON Schema is embedded in the widely adopted OpenAPI specification to define the structure of RESTful APIs. The somewhat newer AsyncAPI specification is a lot like OpenAPI, but with specific support for event-driven systems. Which standard should you use? In mid-2023, if your architecture is mostly based on services and their interactions, go with OpenAPI, since it has more tooling support and is more widely used. If instead you have many asynchronous interactions in your system, or many of the interactions are multi-producer or multi-subscriber, then AsyncAPI is a better choice.","title":"Which JSON Schema specification is best?"},{"location":"events/asyncapi-code.html#xml-schema","text":"The most powerful schema language in common use today for modeling entity representations in APIs is XML Schema. XML Schema is used by SOAP, the Simple Object Access Protocol, which really is not simple. SOAP also has other problems. SOAP was popular 15 years ago but is not popular today. Perhaps in part because of this, XML Schema and XML are also less popular. If you must interface with XML-based systems you might adopt XML Schema in addition to JSON Schema. As of late 2022 the best way to convert between XML Schema and JSON Schema is the commercial product Altova XMLSpy , which may be worth investing if you have to maintain schemas with 50 elements or more.","title":"XML Schema"},{"location":"events/asyncapi-code.html#model-mapping-is-a-chore","text":"If you use domain models and fact-based modeling that effort can form the basis of the entity definitions in your JSON Schema. In this case your OpenAPI or AsyncAPI specifications can import those entity definitions. This approach works well for medium-size systems. You probably won't have such models-as-code for small systems since those don't need models-as-code architecture. As mentioned in the Guide on stages , actively try to avoid over-engineering small systems. On the other end, for large systems that are worked on by multiple teams in parallel you need loose coupling between subsystems so the teams can work somewhat independently. In this case you need to decouple the domain model for a subsystem from the event/API representations of the entities that are communicated with that subsystem. You then end up with significant duplication in architecture and implementation, and ongoing effort to maintain a mapping between internal models and external event specifications. There is no perfect way to avoid this mapping effort. There are many approaches to creating and maintaining model mappings. Caseum makes no recommendations on this topic, beyond the general advice to plan for it deliberately and to then record the design decisions you take on it.","title":"Model mapping is a chore"},{"location":"events/asyncapi-code.html#alternatives-to-json-schema","text":"These are reasonable alternatives worth considering: OData is more prescriptive. If it fits your needs then you can use the OData tooling ecosystem and get functionality for free. OData is used by Microsoft Azure, Dynamics, and Office 365. While it is an open standard with many implementations, the best OData tool support is in the Microsoft ecosystem, specifically in .Net and Visual Studio. GraphQL is a powerful approach to create flexible APIs that are just right for the consumer of that API. This is often worth the investment when building user interfaces, especially mobile applications. For very large systems you may have GraphQL APIs between frontend and backend systems, and OpenAPI or AsyncAPI schemas for use among backend systems. Apache Avro , Apache Thrift , GRPC with Protocol Buffers , Cap'n Proto , ZeroMQ with ABNF , or one of many other such more specific technology choices. If one of these is the right choice for your application, and you define a schema for it, avoid duplicating those schema definitions in JSON Schema.","title":"Alternatives to JSON Schema"},{"location":"events/asyncapi-code.html#alternatives-to-using-an-open-standard","text":"You can work without any standard or schema for your event definitions. This may couple your architecture to a specific (commercial) technology. That is not always bad! For example it may save you significant time and effort and result in a simpler and smaller solution. Many architects and developers intuitively don't like such choices, since they are afraid of the loss of flexibility. Making this tradeoff is an important architecture choice. So, take some time to make this decision and record it. Choosing between open standards and proprietary technology is not all-or-nothing. For example, you can map schemas in architecture but not in code. Specific commercial technology may come with its own reasonable schema language. For example, TIBCO BusinessWorks uses a proprietary schema language for its XML-based message formats. You can use the TIBCO schema language for your event definitions, and then use tooling to convert between TIBCO schema and JSON Schema. You still tie most of your system to the TIBCO schema and protocol. You do have a route toward interoperability by introducing adapters to JSON Schema if that becomes important.","title":"Alternatives to using an open standard"},{"location":"events/asyncapi-code.html#industry-standards-should-influence-architecture-choices","text":"The choice of schema language can depend on the business domain you are working in. There are various industries with extensive standard schema definitions and these are often worth using. For example, the HL7 v3 and CDA standards for healthcare data exchange are based on XML Schema. These standards and probably more widely deployed in 2023 than the newer HL7 FHIR which supports JSON Schema. In other domains, JSON and XML are not appropriate technology and then it makes no sense to use their schema languages. For example, if you work on an automotive system using the CAN bus , messages may defined at a lower protocol layer. In such a case you stick to using a text description of the messages instead of a schema language.","title":"Industry standards should influence architecture choices"},{"location":"events/event-storming.html","text":"Whiteboarding events Use event storming to describe the events of your business domain. Event storming is more useful the more complex the domain that you are designing for. It is especially useful for designing systems with complex business logic or with diverse stakeholders. The event storming website has a lot of good advice on event storming that is not repeated here. All of the event storming advice is quite compatible with the whiteboarding stages of Caseum. How much to focus on events depends on your problem In his tutorials and his book, the creator of event storming, Alberto Brandolini, describes design workshops that start out with event storming as the very first step. This step is taken together with business stakeholders. After capturing the initial events he adds other views and details later, working with the technical team. This approach seems especially appropriate for capturing the description of existing systems. Contrast this with the Caseum stages guide which suggests defining some actors, some stories, and some UI first, before diving into domain events. This approach could be more appropriate for designing new systems from scratch. Try both approaches and see which works best for you! Digital event design using templates The main downside of a digital approach to event views using event storming is that the focus on drawing \"the whole picture\" or \"the entire process\" leads to very large diagrams that don't fit well on monitors. So when switching to digital designs, Caseum instead has an event template for capturing events.","title":"Event whiteboarding"},{"location":"events/event-storming.html#whiteboarding-events","text":"Use event storming to describe the events of your business domain. Event storming is more useful the more complex the domain that you are designing for. It is especially useful for designing systems with complex business logic or with diverse stakeholders. The event storming website has a lot of good advice on event storming that is not repeated here. All of the event storming advice is quite compatible with the whiteboarding stages of Caseum.","title":"Whiteboarding events"},{"location":"events/event-storming.html#how-much-to-focus-on-events-depends-on-your-problem","text":"In his tutorials and his book, the creator of event storming, Alberto Brandolini, describes design workshops that start out with event storming as the very first step. This step is taken together with business stakeholders. After capturing the initial events he adds other views and details later, working with the technical team. This approach seems especially appropriate for capturing the description of existing systems. Contrast this with the Caseum stages guide which suggests defining some actors, some stories, and some UI first, before diving into domain events. This approach could be more appropriate for designing new systems from scratch. Try both approaches and see which works best for you!","title":"How much to focus on events depends on your problem"},{"location":"events/event-storming.html#digital-event-design-using-templates","text":"The main downside of a digital approach to event views using event storming is that the focus on drawing \"the whole picture\" or \"the entire process\" leads to very large diagrams that don't fit well on monitors. So when switching to digital designs, Caseum instead has an event template for capturing events.","title":"Digital event design using templates"},{"location":"events/event-template.html","text":"Describing events with an event description Keep a short, clear list of event descriptions. Caseum provides a simple template for event descriptions in markdown. Event description markdown template Here's a markdown template for capturing events: ### Event: {event name} {Short event summary.} - producers: - {producer #1} - {producer #2} - consumers: - {consumer #1} - {consumer #2} {Detailed event description.} The summary should be a short sentence that describes the event. The producers and components are the actors and components producing and consuming events. The optional detailed description gives more information about the event. Event examples Here are some example event descriptions: Event: PetOwnerArrived Pet owner has arrived at the clinic with their pet. producers: pet owner consumers: receptionist Event: PetOwnerCheckedIn Pet owner has checked in at the reception desk. producers: receptionist consumers: vet Event: AppointmentScheduleChanged Receptionist has adjusted the appointment schedule. producers: receptionist consumers: vet pet owner Alternatives While Markdown templates are fine for actors or stories , they are not ideal for events, where the relationship between events and their producers and consumers are particularly important to see. So here are some alternatives to consider: Visual organization of events using EventCatalog EventCatalog is a nice tool for managing event descriptions. EventCatalog provides a simple markdown template to start with and also allows embedding formal schemas. It provides an open source downloadable tool to visualize those events in different ways. Unfortunately the EventCatalog Markdown format for events does not render well as plain markdown files: you really need to install and use the tool yourself to use the Markdown format. This is why Caseum provides its own simpler template format. But if you can set up and use EventCatalog and make it accessible to everyone on your team, it is a great tool to use instead. More formal event storming via event modeling Adam Dymitruk has described an approach to design called event modeling ( blog post 1 , blog post 2 ), which is conceptually similar to event storming , and has a somewhat more structured approach works well digitally. As a method it is very similar to Caseum during stage 2, creating multiple views. It is similar to event storming in that it focuses on the event view.","title":"Event template"},{"location":"events/event-template.html#describing-events-with-an-event-description","text":"Keep a short, clear list of event descriptions. Caseum provides a simple template for event descriptions in markdown.","title":"Describing events with an event description"},{"location":"events/event-template.html#event-description-markdown-template","text":"Here's a markdown template for capturing events: ### Event: {event name} {Short event summary.} - producers: - {producer #1} - {producer #2} - consumers: - {consumer #1} - {consumer #2} {Detailed event description.} The summary should be a short sentence that describes the event. The producers and components are the actors and components producing and consuming events. The optional detailed description gives more information about the event.","title":"Event description markdown template"},{"location":"events/event-template.html#event-examples","text":"Here are some example event descriptions:","title":"Event examples"},{"location":"events/event-template.html#event-petownerarrived","text":"Pet owner has arrived at the clinic with their pet. producers: pet owner consumers: receptionist","title":"Event: PetOwnerArrived"},{"location":"events/event-template.html#event-petownercheckedin","text":"Pet owner has checked in at the reception desk. producers: receptionist consumers: vet","title":"Event: PetOwnerCheckedIn"},{"location":"events/event-template.html#event-appointmentschedulechanged","text":"Receptionist has adjusted the appointment schedule. producers: receptionist consumers: vet pet owner","title":"Event: AppointmentScheduleChanged"},{"location":"events/event-template.html#alternatives","text":"While Markdown templates are fine for actors or stories , they are not ideal for events, where the relationship between events and their producers and consumers are particularly important to see. So here are some alternatives to consider:","title":"Alternatives"},{"location":"events/event-template.html#visual-organization-of-events-using-eventcatalog","text":"EventCatalog is a nice tool for managing event descriptions. EventCatalog provides a simple markdown template to start with and also allows embedding formal schemas. It provides an open source downloadable tool to visualize those events in different ways. Unfortunately the EventCatalog Markdown format for events does not render well as plain markdown files: you really need to install and use the tool yourself to use the Markdown format. This is why Caseum provides its own simpler template format. But if you can set up and use EventCatalog and make it accessible to everyone on your team, it is a great tool to use instead.","title":"Visual organization of events using EventCatalog"},{"location":"events/event-template.html#more-formal-event-storming-via-event-modeling","text":"Adam Dymitruk has described an approach to design called event modeling ( blog post 1 , blog post 2 ), which is conceptually similar to event storming , and has a somewhat more structured approach works well digitally. As a method it is very similar to Caseum during stage 2, creating multiple views. It is similar to event storming in that it focuses on the event view.","title":"More formal event storming via event modeling"},{"location":"guides/as-is-to-be.html","text":"As-is and to-be designs The most important architecture description of the existing system is the one as it currently exists, \"as-is\". Learning, agreeing, and knowing how things actually are is very important. Too many teams focus only on what should be or what could be, \"to-be\". This is a mistake. When you work with individual assumptions of how things are instead of a shared understanding, you will build the wrong thing the wrong way slowly. Finding facts When working with an existing system, it is common for its architecture description to be a little or a lot out of date. Often the only design document is of what teams intended to build, not what they actually built. This means designs cannot be trusted. To create a shared as-is understanding of a software architecture, gather all the descriptions available and ask the maintainers of the system whether the descriptions are up-to-date. Descriptions that are out-of-date should be flagged as such. They do not all need to be updated. Hold interactive whiteboarding workshops to draw new pictures of the system as-is. Any box, line, circle, or other element you draw on the whiteboard should be backed up by a fact. Look for evidence in the running system, its source code, or the knowledge of experts. Do not draw things that may be true or are assumed to be true. Most systems have only a few of the Caseum views. Drawing the other views helps to find more facts. Capture all the information across different views, iterating and refining the as-is design as you learn more together. When you have a complete set of facts, tell the story of the as-is system to each other several times, finding more facts and information as you do so. Looking at example data to find facts You can understand a lot about existing systems by looking at their data inputs and outputs. Capture UI forms and screens, API requests and responses, reports, and dashboards. It can help to print these out and stick them on the walls next to your whiteboards. As you understand more, use fact-based whiteboarding to draw the data model underlying and supporting the examples. Check each type and each link between types against the examples. Event storming to find facts An event storming workshop is a great way to find these as-is facts, especially if you have access to business stakeholders. Especially for long-running systems, their current use can be very different from the original intent, and this is important to capture. Working backwards The guide on stages of design suggests working iteratively in this order: Actors Stories UI Events Components Models Starting with actors, stories, and UI helps to make the rest of the design user-centric. When documenting existing systems, you can work backward instead. First capture all the facts you can find about the system, then start to involve experts and stakeholders to understand how the system is used and why. From as-is to to-be Many engineers are inclined to talk about solving problems as they see them. When documenting the as-is architecture, it is natural to want to talk about changing it to fix things. Rather than prevent such thoughts completely, instead capture the ideas about possible changes as you go, and create a backlog of design ideas. Most teams spend too much time on to-be designs and not enough on as-is designs. If you don't know where you are, it is difficult to get to where you want to be. Complete the as-is design to a good level of quality and detail. Once the as-is description of the system is reasonably complete and everyone on the team can tell the same story about the system from a common shared understanding, it is time to start designing changes to the existing system to end up in a new situation. It can be tempting to design the to-be situation based on all the new ideas that were already generated. Instead, stay user-focused. Describe the needs of actors that are not being (fully) met by the existing system and the stories that would meet their needs. Then design just enough changes to the existing system to meet those needs. For many existing systems, the unmet needs are those of the maintainers of the existing system. The maintainers spend so much time on keeping the lights on that they cannot make the changes their users need. In this case, it can help to consider these maintainers as users and to introduce a platform layer to capture their needs. Imagining big changes Sometimes when doing design work for an existing system, there is a hope that radical new technology creates a big improvement. The existing system may be using legacy technology. Its maintainers may have moved on. Stakeholders are interested in rebuilding or replatforming such a system in a big bang. But such big-bang migrations do not work. Do not promise otherwise. In such a situation, the to-be system can be designed as a completely new system following the guide to stages . Such a to-be system can help to convince non-technical stakeholders. Once the new to-be system is imagined, design many small step-by-step migrations from the as-is situation to the to-be situation. Keep a sequence of records that move the current system incrementally to the new situation. If you cannot design such a sequence, change the to-be design so that the incremental migration becomes possible. The larger and older the existing system, the longer the migration path seems, and the higher the temptation becomes to consider a big-bang change...the lower the chance of success of such big-bang change becomes. Other terminology 'Ist' is the German term for as-is, and 'Soll' is the German term for to-be, so in German you can speak of 'Ist und Soll' to describe the current and future situation. The steps to take to go from as-is to to-be architecture are crossing a gap, so you can speak of 'gap analysis' to describe part of the design work of crossing the gap, a popular phrase in business language. Note that beyond just doing the analysis, you should explicitly design the migration path, as described above.","title":"As-is and to-be"},{"location":"guides/as-is-to-be.html#as-is-and-to-be-designs","text":"The most important architecture description of the existing system is the one as it currently exists, \"as-is\". Learning, agreeing, and knowing how things actually are is very important. Too many teams focus only on what should be or what could be, \"to-be\". This is a mistake. When you work with individual assumptions of how things are instead of a shared understanding, you will build the wrong thing the wrong way slowly.","title":"As-is and to-be designs"},{"location":"guides/as-is-to-be.html#finding-facts","text":"When working with an existing system, it is common for its architecture description to be a little or a lot out of date. Often the only design document is of what teams intended to build, not what they actually built. This means designs cannot be trusted. To create a shared as-is understanding of a software architecture, gather all the descriptions available and ask the maintainers of the system whether the descriptions are up-to-date. Descriptions that are out-of-date should be flagged as such. They do not all need to be updated. Hold interactive whiteboarding workshops to draw new pictures of the system as-is. Any box, line, circle, or other element you draw on the whiteboard should be backed up by a fact. Look for evidence in the running system, its source code, or the knowledge of experts. Do not draw things that may be true or are assumed to be true. Most systems have only a few of the Caseum views. Drawing the other views helps to find more facts. Capture all the information across different views, iterating and refining the as-is design as you learn more together. When you have a complete set of facts, tell the story of the as-is system to each other several times, finding more facts and information as you do so.","title":"Finding facts"},{"location":"guides/as-is-to-be.html#looking-at-example-data-to-find-facts","text":"You can understand a lot about existing systems by looking at their data inputs and outputs. Capture UI forms and screens, API requests and responses, reports, and dashboards. It can help to print these out and stick them on the walls next to your whiteboards. As you understand more, use fact-based whiteboarding to draw the data model underlying and supporting the examples. Check each type and each link between types against the examples.","title":"Looking at example data to find facts"},{"location":"guides/as-is-to-be.html#event-storming-to-find-facts","text":"An event storming workshop is a great way to find these as-is facts, especially if you have access to business stakeholders. Especially for long-running systems, their current use can be very different from the original intent, and this is important to capture.","title":"Event storming to find facts"},{"location":"guides/as-is-to-be.html#working-backwards","text":"The guide on stages of design suggests working iteratively in this order: Actors Stories UI Events Components Models Starting with actors, stories, and UI helps to make the rest of the design user-centric. When documenting existing systems, you can work backward instead. First capture all the facts you can find about the system, then start to involve experts and stakeholders to understand how the system is used and why.","title":"Working backwards"},{"location":"guides/as-is-to-be.html#from-as-is-to-to-be","text":"Many engineers are inclined to talk about solving problems as they see them. When documenting the as-is architecture, it is natural to want to talk about changing it to fix things. Rather than prevent such thoughts completely, instead capture the ideas about possible changes as you go, and create a backlog of design ideas. Most teams spend too much time on to-be designs and not enough on as-is designs. If you don't know where you are, it is difficult to get to where you want to be. Complete the as-is design to a good level of quality and detail. Once the as-is description of the system is reasonably complete and everyone on the team can tell the same story about the system from a common shared understanding, it is time to start designing changes to the existing system to end up in a new situation. It can be tempting to design the to-be situation based on all the new ideas that were already generated. Instead, stay user-focused. Describe the needs of actors that are not being (fully) met by the existing system and the stories that would meet their needs. Then design just enough changes to the existing system to meet those needs. For many existing systems, the unmet needs are those of the maintainers of the existing system. The maintainers spend so much time on keeping the lights on that they cannot make the changes their users need. In this case, it can help to consider these maintainers as users and to introduce a platform layer to capture their needs.","title":"From as-is to to-be"},{"location":"guides/as-is-to-be.html#imagining-big-changes","text":"Sometimes when doing design work for an existing system, there is a hope that radical new technology creates a big improvement. The existing system may be using legacy technology. Its maintainers may have moved on. Stakeholders are interested in rebuilding or replatforming such a system in a big bang. But such big-bang migrations do not work. Do not promise otherwise. In such a situation, the to-be system can be designed as a completely new system following the guide to stages . Such a to-be system can help to convince non-technical stakeholders. Once the new to-be system is imagined, design many small step-by-step migrations from the as-is situation to the to-be situation. Keep a sequence of records that move the current system incrementally to the new situation. If you cannot design such a sequence, change the to-be design so that the incremental migration becomes possible. The larger and older the existing system, the longer the migration path seems, and the higher the temptation becomes to consider a big-bang change...the lower the chance of success of such big-bang change becomes.","title":"Imagining big changes"},{"location":"guides/as-is-to-be.html#other-terminology","text":"'Ist' is the German term for as-is, and 'Soll' is the German term for to-be, so in German you can speak of 'Ist und Soll' to describe the current and future situation. The steps to take to go from as-is to to-be architecture are crossing a gap, so you can speak of 'gap analysis' to describe part of the design work of crossing the gap, a popular phrase in business language. Note that beyond just doing the analysis, you should explicitly design the migration path, as described above.","title":"Other terminology"},{"location":"guides/drawio.html","text":"Drawing architecture diagrams with draw.io draw.io (aka diagrams.net) is a free and open source diagramming tool that can be used to draw architecture diagrams. It is available as a web application and as a desktop application for Windows, macOS and Linux. While draw.io is not the most powerful diagramming software, is not an architecture-specific tool, and does not support formal modeling, it is good enough . Because it is open source, multi-platform, and has a web-based version, it is accessible . This accessibility is why it is the tool of choice for digital architecture diagrams in Caseum. Templates The following Caseum templates are available for draw.io: View Draw.io Library Components C4 Draw.io Library Actors use markdown Stories use markdown Events ES Draw.io Library UI Wireframes Draw.io Library Models TLM Draw.io Library Storing draw.io diagrams Store your diagrams where you store your architecture documentation: If you use Confluence, use the draw.io plugin for confluence . If you use SharePoint, download the desktop version and save the files in SharePoint. If you use GitHub, store the files in your GitHub repository. VSCode and draw.io The draw.io integration for VSCode allows you to edit draw.io diagrams in VSCode. It is a great way to keep your diagrams in the same repository as your code, and to keep them in sync with your code. github.dev and draw.io The draw.io integration for VSCode also works in github.dev . Replace github.com with github.dev in the URL of any draw.io diagram on GitHub repository to open it in github.dev. For example, you can try editing the Caseum logo .","title":"Draw.io for architecture"},{"location":"guides/drawio.html#drawing-architecture-diagrams-with-drawio","text":"draw.io (aka diagrams.net) is a free and open source diagramming tool that can be used to draw architecture diagrams. It is available as a web application and as a desktop application for Windows, macOS and Linux. While draw.io is not the most powerful diagramming software, is not an architecture-specific tool, and does not support formal modeling, it is good enough . Because it is open source, multi-platform, and has a web-based version, it is accessible . This accessibility is why it is the tool of choice for digital architecture diagrams in Caseum.","title":"Drawing architecture diagrams with draw.io"},{"location":"guides/drawio.html#templates","text":"The following Caseum templates are available for draw.io: View Draw.io Library Components C4 Draw.io Library Actors use markdown Stories use markdown Events ES Draw.io Library UI Wireframes Draw.io Library Models TLM Draw.io Library","title":"Templates"},{"location":"guides/drawio.html#storing-drawio-diagrams","text":"Store your diagrams where you store your architecture documentation: If you use Confluence, use the draw.io plugin for confluence . If you use SharePoint, download the desktop version and save the files in SharePoint. If you use GitHub, store the files in your GitHub repository.","title":"Storing draw.io diagrams"},{"location":"guides/drawio.html#vscode-and-drawio","text":"The draw.io integration for VSCode allows you to edit draw.io diagrams in VSCode. It is a great way to keep your diagrams in the same repository as your code, and to keep them in sync with your code.","title":"VSCode and draw.io"},{"location":"guides/drawio.html#githubdev-and-drawio","text":"The draw.io integration for VSCode also works in github.dev . Replace github.com with github.dev in the URL of any draw.io diagram on GitHub repository to open it in github.dev. For example, you can try editing the Caseum logo .","title":"github.dev and draw.io"},{"location":"guides/platforms.html","text":"Designing platforms For large systems it can be helpful to have a standardized platform on top of which the rest of the software is built. The platform may provide libraries, frameworks, shared services, or a hosting environment. Do not describe this platform in detail as part of the Caseum documentation that also describes your end user system, You can document it as a distinct software system where the users are the developers. You can have multiple layers of such platforms. For example, you may have one or more public cloud providers and a private cloud provider. On top of these clouds you may have a standardized container platform. You may have a standardized microservices framework deployed on that container platform. Finally, you may build many applications using that microservices framework. This arrangement only makes sense for large systems of systems with many teams working on them. It is quite common for organizations to set up specialized platform teams too early. For smaller teams, choose simple and standard technology components that do not require much architecture work and focus on designing your application for your end users.","title":"Designing platforms"},{"location":"guides/platforms.html#designing-platforms","text":"For large systems it can be helpful to have a standardized platform on top of which the rest of the software is built. The platform may provide libraries, frameworks, shared services, or a hosting environment. Do not describe this platform in detail as part of the Caseum documentation that also describes your end user system, You can document it as a distinct software system where the users are the developers. You can have multiple layers of such platforms. For example, you may have one or more public cloud providers and a private cloud provider. On top of these clouds you may have a standardized container platform. You may have a standardized microservices framework deployed on that container platform. Finally, you may build many applications using that microservices framework. This arrangement only makes sense for large systems of systems with many teams working on them. It is quite common for organizations to set up specialized platform teams too early. For smaller teams, choose simple and standard technology components that do not require much architecture work and focus on designing your application for your end users.","title":"Designing platforms"},{"location":"guides/records.html","text":"Recording decisions Architecture records the important design decisions for a software system. The records are for communicating with current and future people working on and with the software. Architecture is done by thinking together using views and tools that can be used by all the people working on the software. Record the important decisions and why they were made. Change the decisions when needed. Architecture should be as simple as possible, as high level as possible, as informal as possible. It's better to have less architecture at a higher level that is kept up-to-date than have detailed information that's wrong. Tooling advice for recording decisions Use tools to help communicate simply and effectively. Using fewer, simpler, and more informal tools works well with Caseum. When everyone working on the software is regularly in the same physical place, the walls of that place are a good place for the architecture record. In all other cases, use a digital communication system that everyone can use. The system should keep a permanent record and support images and other files. Use the system already in place if possible. Good systems include chat systems such as Slack or e-mail groups such as Office Teams/SharePoint groups. When working on projects for multiple months, create a digital library. Good systems include wikis such as Confluence or online drives such as Office Teams/SharePoint drives. Use the system already in place if possible. When making digital diagrams, another tool can be integrated/linked with the library, such as the draw.io Confluence diagramming plugin. When working with models as code or executable specifications, add a source control system like Git for those and link/integrate it with the digital library. Consider Architecture Decision Records (ADRs) Sometimes the approach for recording decisions is a little more formalized, using Architecture Decision Records . You can combine ADRs with Caseum, but be careful: ADR approaches often make things more formal than needed. The people involved in the project may start to expect certain people to be involved in a certain way, to act as owners or approvers or gatekeepers of the architecture. ADR approaches often supply detailed templates with a lot of details to capture about the decision, rather than just the decision itself. These details can be a distraction from the most important stuff, leading to people spending time filling out forms instead of thinking together and communicating. ADR approaches often advocate keeping all records in technical version control systems like Git. Some people involved in the project (like product managers, key stakeholders, project managers) may not be comfortable using Git. If you don't need the formality, keep things simpler. If you don't know if you need the formality, don't introduce it until you do. A good sign that you need this kind of structure is if there is too much information that people are actually spending a lot of time looking for decision records, or looking for the right version of a decision record. That is more common on projects that last for more than 9 months, include more than 7 people, or have more than 50 diagrams. Consider Requests For Discussions (RFDs) Sometimes the approach for making decisions is a little more formalized, using Requests For Discussions (RFDs) . You can combine RFDs with Caseum, but be careful: the same formal focus that comes with ADRs can come with RFDs. RFDs work best when your team or organization has established a strong culture of healthy discussion. Avoid RFCs, Enhancement Proposals, and Detailed Design Documents Large, complex safety-critical systems often use decision records that are more formal, using standardized processes to make the decisions. Do not use Caseum for such systems. Such approaches include RFCs such as those used to design the internet: IETF RFCs Enhancement Proposals such as those used to design programming languages Python Formal design descriptions such as those used to design military systems: DOD System Design Descriptions (SDD) Standardized formal design processes such as those used to design space systems: ESA PSS-05-0 and ECSS-E-ST-40C Avoid UML, ArchiMate, RUP, TOGAF, IEEE 1016 Architecture records can also be kept more formally using enterprise standards. Borrow good ideas from these standards but do not combine them with Caseum. Such standards include The Universal Modeling Language (UML) The Open Group ArchiMate The Open Group Architecture Framework (TOGAF) The Rational Unified Process (RUP) The IEEE 1016 Software Design Description (SDD)","title":"Recording decisions"},{"location":"guides/records.html#recording-decisions","text":"Architecture records the important design decisions for a software system. The records are for communicating with current and future people working on and with the software. Architecture is done by thinking together using views and tools that can be used by all the people working on the software. Record the important decisions and why they were made. Change the decisions when needed. Architecture should be as simple as possible, as high level as possible, as informal as possible. It's better to have less architecture at a higher level that is kept up-to-date than have detailed information that's wrong.","title":"Recording decisions"},{"location":"guides/records.html#tooling-advice-for-recording-decisions","text":"Use tools to help communicate simply and effectively. Using fewer, simpler, and more informal tools works well with Caseum. When everyone working on the software is regularly in the same physical place, the walls of that place are a good place for the architecture record. In all other cases, use a digital communication system that everyone can use. The system should keep a permanent record and support images and other files. Use the system already in place if possible. Good systems include chat systems such as Slack or e-mail groups such as Office Teams/SharePoint groups. When working on projects for multiple months, create a digital library. Good systems include wikis such as Confluence or online drives such as Office Teams/SharePoint drives. Use the system already in place if possible. When making digital diagrams, another tool can be integrated/linked with the library, such as the draw.io Confluence diagramming plugin. When working with models as code or executable specifications, add a source control system like Git for those and link/integrate it with the digital library.","title":"Tooling advice for recording decisions"},{"location":"guides/records.html#consider-architecture-decision-records-adrs","text":"Sometimes the approach for recording decisions is a little more formalized, using Architecture Decision Records . You can combine ADRs with Caseum, but be careful: ADR approaches often make things more formal than needed. The people involved in the project may start to expect certain people to be involved in a certain way, to act as owners or approvers or gatekeepers of the architecture. ADR approaches often supply detailed templates with a lot of details to capture about the decision, rather than just the decision itself. These details can be a distraction from the most important stuff, leading to people spending time filling out forms instead of thinking together and communicating. ADR approaches often advocate keeping all records in technical version control systems like Git. Some people involved in the project (like product managers, key stakeholders, project managers) may not be comfortable using Git. If you don't need the formality, keep things simpler. If you don't know if you need the formality, don't introduce it until you do. A good sign that you need this kind of structure is if there is too much information that people are actually spending a lot of time looking for decision records, or looking for the right version of a decision record. That is more common on projects that last for more than 9 months, include more than 7 people, or have more than 50 diagrams.","title":"Consider Architecture Decision Records (ADRs)"},{"location":"guides/records.html#consider-requests-for-discussions-rfds","text":"Sometimes the approach for making decisions is a little more formalized, using Requests For Discussions (RFDs) . You can combine RFDs with Caseum, but be careful: the same formal focus that comes with ADRs can come with RFDs. RFDs work best when your team or organization has established a strong culture of healthy discussion.","title":"Consider Requests For Discussions (RFDs)"},{"location":"guides/records.html#avoid-rfcs-enhancement-proposals-and-detailed-design-documents","text":"Large, complex safety-critical systems often use decision records that are more formal, using standardized processes to make the decisions. Do not use Caseum for such systems. Such approaches include RFCs such as those used to design the internet: IETF RFCs Enhancement Proposals such as those used to design programming languages Python Formal design descriptions such as those used to design military systems: DOD System Design Descriptions (SDD) Standardized formal design processes such as those used to design space systems: ESA PSS-05-0 and ECSS-E-ST-40C","title":"Avoid RFCs, Enhancement Proposals, and Detailed Design Documents"},{"location":"guides/records.html#avoid-uml-archimate-rup-togaf-ieee-1016","text":"Architecture records can also be kept more formally using enterprise standards. Borrow good ideas from these standards but do not combine them with Caseum. Such standards include The Universal Modeling Language (UML) The Open Group ArchiMate The Open Group Architecture Framework (TOGAF) The Rational Unified Process (RUP) The IEEE 1016 Software Design Description (SDD)","title":"Avoid UML, ArchiMate, RUP, TOGAF, IEEE 1016"},{"location":"guides/stages.html","text":"Architecture stages Caseum has three stages of architecture to help do just enough architecture: don't go to the next stage unless you need it. Prefer working software over comprehensive documentation, so do as little software architecture as results in good working software. Simple small systems should have simple small architectures. Single teams should have informal architectures. When small systems get bigger their architectures grow with them. When teams get bigger and split into multiple teams their design processes grow with them. Design a new system to learn Caseum This guide is for starting from scratch. Most architecture work is not for completely new software systems but starting from scratch is the easiest way to learn Caseum. See the guide on as-is and to-be for working on existing systems. Stage 0: no need for Caseum Small systems of 2000 lines of code or less or those built by 3 people or fewer do not need to use Caseum or any other specific approach to architecture. This stays true while all people on the team understand the whole system and the system quality remains high. Only once the software system doesn't fit in everyone's head should you consider starting with Caseum. Likewise, if you are or will be working on something that is completely new where even the problem space is not clear yet, do not start with software architecture and so do not start with Caseum. Something like a design sprint may be a better start. Once you have built and validated one or a couple of prototypes you may be ready for architecture work. Stage 1: structured brainstorming & whiteboarding When you have more than 3 people working on a system that is getting bigger, you can start brainstorming and whiteboarding together in a planned manner using Caseum step 1. It does not really matter in which order you make the different Caseum views. Just make all the views that make sense, all at the same time, and keep going until you think you have all the important information, or you are almost out of time. You can use the general guide on whiteboarding . Caseum whiteboarding step by step \"Everything all at once\" is not always easy to do. If you need more structure, try this order: Actors : name the roles of the key actors using the software system. write their needs for which they use the systems. You can use the guide on whiteboarding actors . Stories : Write the main goals the actors have that they use the software system for. Break bigger goals down into coarse-grained scenarios called \"epics\", from \"epic story\" Describe the epics in terms of activities by the actors for which they use the system. You can use the guide on whiteboarding stories . UI : Sketch some basic wireframes of the UI the actors will use, if any. If actors use CLIs or APIs or get e-mails or reports, then sketch out some of those. You can use the guide on whiteboarding wireframes . Events : define the commands the actors will issue through these UIs to start on their activities. Outline how the commands turn into different events that happen in the system. Outline how the system will react to those events. If you have a lot of events, try and group them into domains. If you can, define coarse-grained events connecting the domains. If a command, event, or reaction is not obvious to everyone, then add some examples. You can use the guide on event storming . Components : Make a C4 context diagram showing the actors and their activities interacting with the system. Make a C4 component diagram of the key components that make up the system so that all the different events reach a component. Add the components needed to make those other components work. Give them a clear name. Add a description if it's not obvious to everyone. Keep adding components until all the important components are sketched out. If you have a lot of components, group them into stacks of closely related components and make a C4 container diagram. If you have a lot of stacks, group them together into several distinct systems and make a C4 system landscape diagram. If it is important to decide now what technology to use for some of the components then write the technology used under the name. You can use the guide on whiteboarding C4 . Models : Draw circles for the main types that make up the main events. Add links between those main types as arrows and label the kind of link. If a type or link is not obvious to everyone then add some example facts. Add additional important facts about each type that needs to be in the software system using additional facts and links. Keep adding facts until enough of the types are sketched out that it is clear enough what all the events look like. You can use the guide on whiteboarding facts . Some advice while working through this order: Focus on capturing the most important design decisions. It is not important to be complete or have all the details. Try to go fast through each step. When you start slowing down during one of these steps, just move to the next one. During a later step you may discover other important information on previous steps, so go back and add it. If it seems like your group disagrees about a particular detail, slow down a bit. First figure out what the disagreement is. Write down a question. Then have a brief discussion. If consent on an answer is not quickly found, capture it as a topic to detail later. If you use ADRs or RFDs , this may be a good topic for such a document. Focusing in on specific concerns Even though Caseum has 6 different views there can be yet other concerns that need more focus. For example, you may want to review the designs for security check the designs for consistency with some standard analyze the designs for quality attributes (non-functional requirements) analyze the designs for technology/platform choices analyze the designs for lower-level/infrastructure needs analyze the designs for architecture characteristics like cohesion or modularity perform an AWS well-architected review or another similar structured design review process For most of these reviews you do not need to complete the Models view. You do need the Components view, and to have a good Components view you should have the other views to some level of detail as well. To do so, draw the designs as you otherwise would. Then do an additional round to annotate the whiteboards based on those other issues. During the review write the issues on notes on the board, but do not immediately try to solve the issues. After you capture all the issues, prioritize them. Discuss only the important ones in more detail, and only as much as time allows. Iterating during stage 1 After you have whiteboarded initial versions of all the views, stop designing and implement some parts of the system. During implementation, you will learn a lot more which will inform your next iteration of the architecture. After you have implemented some software, make sure to test it, ideally by getting an initial production system in the hands of end users. When you do this you will learn a lot more. After your first iteration, evaluate whether your implementation is very different from your architecture. If the designs mostly match your results, and you all sort-of know the next steps to take to implement the next iteration, you may not need to do more design yet. During Caseum stage 1, do not worry too much about capturing the architecture permanently. There is a lot of value in just wiping (some of) the whiteboards and redrawing the design. Each time you redraw a picture you are likely to focus in more on what is important, leaving out the details that don't need to be in the picture. Each time you do this is an opportunity to discuss the design further and create a better shared understanding of what to do. It is also an opportunity to practice drawing and designing. This may sound inefficient, but it is very effective. Try it! Time budget for architecture Experienced teams that have clear user goals & needs, and have built similar systems before, using similar technology, may only need to spend only about 5% of their time creating and maintaining their design, i.e. about half a day at the beginning of a two-week sprint. Sometimes only a few of the people on the team need to do the design and the rest of the team can implement it. If the team has less experience, the user needs are less clear, the system architecture is very new, or the implementation technology is new, it can be worthwhile to spend more time on architecture and design, up to perhaps about 20% of all the time available, or about 2 afternoons a week. If you've spent more than a day a week doing architecture work, and this is not enough to know what to build during the rest of the week, spend some more time! This is one good indicator to start capturing designs more carefully - you may need to move to stage 2. Stage 2: digital diagrams and decision records During stage 2, you may still use whiteboards sometimes, but you also create and maintain a digital version of your designs. Some of the Caseum views work best as text documents. Caseum recommends Markdown templates for text documents and provides templates. Other Caseum views work best as visual diagrams. Caseum recommends draw.io for diagrams and provides templates and libraries. Actively try to avoid stage 2 You want to stay in stage 1 if you can. Do not start immediately with step 2, for most new projects maintaining a set of digital diagrams is too much structure too quickly. At best doing all that work will slow you down. What happens more often is that you stop maintaining or improving your design, and the designs grow stale, no longer matching the software system that is being built. It is better to have up-to-date designs in medium detail on a whiteboard, than to have out-of-date designs being ignored on a wiki. On the other hand if you do find yourself redrawing the same picture a lot, or explaining the same concepts over and over again, then it is time to move from phase 1 to phase 2. There's other times when your team is usually fine with whiteboarding, but you need some high quality digital artifacts for some other reason (like an important presentation or a compliance audit). If that's the case, by all means produce the digital diagrams. But after the event, throw the files away! Ok, so perhaps you won't actually throw the diagrams away, fine. It's ok to print them out and stick them on your whiteboards. But what you should not do is start investing the effort to keep the fancy digital pictures up-to-date if you have no real need for them. Make digital versions of your stage 1 views Your first step is to digitize everything. As you switch to a digital form, it is natural to be more precise and add more detail. Take the time to get the detail right. Usually that involves looking at the actual software system, so you don't fill in the detail based on your memory but based on the current reality. After you complete the first version of the digital views, review them. You may see things you want to change or improve in the system. Make a list, prioritize it, and perhaps plan to make the improvements. Caseum digital designs step by step Actors : fill out a role description for each of your actors. You can use the role template . Stories : break down all your epics and activities into clear user stories. You can use the story template . Events : group your events by domain, if you did not do so yet. Give the domains clear names. create a description for each event. You can use the event template . Components : Create digital versions of all your existing C4 diagrams. Make sure all your actor roles are in the C4 context diagram. Make sure all your event domains are in the C4 diagrams. Create the C4 container diagram if you didn't have one yet. You can use the C4 template . Models : Do not directly create digital versions of your model diagrams. Instead, create your model diagrams based on the model definitions in your software systems (like your domain model or your SQL database definition scripts). Object-oriented or table-oriented modeling is more common than the fact-based modeling that Caseum recommends. You can read why fact-based modeling is great and decide to try it, or, you can use a modeling approach you already know. If you decide to use fact-based modeling, you can use the tlm template . UI : Maintaining digital UI designs is relatively a lot of effort that may not be worth it for you just for your architecture. If you are using a modern design tool like Figma already, you can use those designs instead. If you do not have such digital designs, you can use the UI template to make digital wireframes. You can also choose to maintain your UI designs on paper or on whiteboards while you digitize the other views. Keep more detailed records See the guide on keeping records . During step 1 you may have not kept detailed records. If so, during step 2 it is worth to start doing so. This is also a good time to consider the use of ADRs or RFDs. Iterating during step 2 The more architecture views you have to maintain, the more useful it becomes to work on them a little bit regularly. If you only do a \"big bang\" architecture update every few months, there are long periods when your architecture is not so useful since it is too out-of-date to use. You could make updating the diagrams part of your definition-of-ready or your definition-of-done . Alternatively you could update the diagrams periodically, like at the beginning or end of a 2-week sprint. Time budget for architecture Creating the initial digital versions of all the architecture views can be a significant one-off investment, perhaps up to a couple of weeks of effort if you managed to stay in stage 1 for as long as is recommended. After that initial investment, maintaining the digital views will also take some time on an ongoing basis. It shouldn't take more than about 20% of your time, and 10% would be better. If you find you do not have time for maintaining the diagrams, as a first step, clearly label the diagrams out-of-date. If the lack of up-to-date diagrams starts to cause you issues, then decide what to do. A good approach may be to only maintain the higher-level designs. Because those may change less frequently, this will be less effort. If you have many stories, events, components, or models, it may become more efficient to maintain them as code instead of as visual diagrams. That efficiency is the main reason to switch to Caseum stage 3. Handling non-functional requirements Many software architectures focus too much on interesting technical requirements and as a result systems become more rigid and complex than needed. To help combat this, Caseum focuses on working iteratively, keeping users and their needs in mind throughout the design process. However, for larger systems the non-functional requirements may become relatively more and more challenging to meet. Such needs are often not easy to visualize either. Instead, consider keeping more detailed records such as Architecture Decision Records (ADRs) or Requests For Discussion (RFDs) that explain how the non-functional requirements are being met. Stage 3: models as code and executable specifications During stage 3 you define and maintain your Caseum architecture not using informal visuals and text documents, but with structured models as code and with executable specifications. You may generate some parts of your software from those models, or generate some of those models from your software. Actively try to avoid stage 3 Many engineers like the idea of models-as-code in theory. It appeals to them because they like coding, so coding the architecture also makes sense. There is also a promise of higher consistency. But such a technical approach can have serious downsides too: Requiring coding skills to work on the architecture, excluding some team members Rigid inflexible technical tools making it hard to flexibly express the architecture of the system in the most clear way Spending effort on dealing with technical tools and frameworks instead of communicating design decisions and building working software The larger and more complex a software system, the more likely there is value in adopting models as code. As a rule of thumb, it makes sense to start to evaluate using such tools when you have one system with over 50 components, over 100 models, and/or over 50 people working on it. Note that if you created a great software design, you can end up with many independent small systems maintained by small teams that have limited interaction. In that case, even for very large software landscapes, you still do not ever need stage 3! Experiment! Rather than just switch from stage 2 to stage 3, do some experiments. Create some initial prototype versions of structured models and specifications. Measure how much time it takes to do so. Then maintain those prototypes for some period (perhaps 3 2-week sprints) and see how much time that takes. Evaluate whether you save time compared to maintaining the visual diagrams. If so, great! Otherwise, are there enough other benefits? Caseum models as code step by step Stories : Start writing your stories in Gherkin format. You can consider using BDD and automate testing using the Gherkin stories, which is a great benefit of Gherkin, which is why Stories are a good view to start Caseum stage 3 with. You can use the Gherkin coding guide . Components : C4 has a great textual format in Structurizr that is worth using if you have a lot of components. You can use the C4 coding guide . Models : If you use advanced fact-based modeling, there are good bidirectional mappings between software systems and textual specifications, and you should consider them. For example, if you adopted TLM, you can use the TLM coding guide . On the other hand, if you use UML or other object-oriented modeling techniques, do not use automated bidirectional mapping tools, because they produce low-quality code. In this case it is better to work \"code first\": write source code and then generate the model definitions from your code. Events : You can consider using a formal standard for defining and maintaining event definitions. If you have a lot of system-to-system events, you may already be using detailed technical specifications for the APIs, like Swagger for REST APIs or Avro for messaging systems. If so, there is little value in codifying the event view separately. Otherwise, you can use the AsyncAPI coding guide . Actors : There's no executable specification for actors. Maintain the role descriptions as text, like in phase 2. UI : There's no executable specification for UI. If you have a large team working on a large software system that includes UI, then you probably have dedicated UI designers. Let them maintain the UI views and link to it from your architecture documentation. Beyond stage 3 For very large systems of systems you may need to go beyond Caseum. Platforms If you have many developer teams you may consider a platform team that focuses on providing a platform layer to the other developer teams. See the guide on platforms for how to use Caseum in that situation. Formal (enterprise) standards If you are building very large systems, you may consider a more formal architecture approach. Do not use Caseum to design space shuttles or nuclear power plants.","title":"Architecture stages"},{"location":"guides/stages.html#architecture-stages","text":"Caseum has three stages of architecture to help do just enough architecture: don't go to the next stage unless you need it. Prefer working software over comprehensive documentation, so do as little software architecture as results in good working software. Simple small systems should have simple small architectures. Single teams should have informal architectures. When small systems get bigger their architectures grow with them. When teams get bigger and split into multiple teams their design processes grow with them.","title":"Architecture stages"},{"location":"guides/stages.html#design-a-new-system-to-learn-caseum","text":"This guide is for starting from scratch. Most architecture work is not for completely new software systems but starting from scratch is the easiest way to learn Caseum. See the guide on as-is and to-be for working on existing systems.","title":"Design a new system to learn Caseum"},{"location":"guides/stages.html#stage-0-no-need-for-caseum","text":"Small systems of 2000 lines of code or less or those built by 3 people or fewer do not need to use Caseum or any other specific approach to architecture. This stays true while all people on the team understand the whole system and the system quality remains high. Only once the software system doesn't fit in everyone's head should you consider starting with Caseum. Likewise, if you are or will be working on something that is completely new where even the problem space is not clear yet, do not start with software architecture and so do not start with Caseum. Something like a design sprint may be a better start. Once you have built and validated one or a couple of prototypes you may be ready for architecture work.","title":"Stage 0: no need for Caseum"},{"location":"guides/stages.html#stage-1-structured-brainstorming-whiteboarding","text":"When you have more than 3 people working on a system that is getting bigger, you can start brainstorming and whiteboarding together in a planned manner using Caseum step 1. It does not really matter in which order you make the different Caseum views. Just make all the views that make sense, all at the same time, and keep going until you think you have all the important information, or you are almost out of time. You can use the general guide on whiteboarding .","title":"Stage 1: structured brainstorming &amp; whiteboarding"},{"location":"guides/stages.html#caseum-whiteboarding-step-by-step","text":"\"Everything all at once\" is not always easy to do. If you need more structure, try this order: Actors : name the roles of the key actors using the software system. write their needs for which they use the systems. You can use the guide on whiteboarding actors . Stories : Write the main goals the actors have that they use the software system for. Break bigger goals down into coarse-grained scenarios called \"epics\", from \"epic story\" Describe the epics in terms of activities by the actors for which they use the system. You can use the guide on whiteboarding stories . UI : Sketch some basic wireframes of the UI the actors will use, if any. If actors use CLIs or APIs or get e-mails or reports, then sketch out some of those. You can use the guide on whiteboarding wireframes . Events : define the commands the actors will issue through these UIs to start on their activities. Outline how the commands turn into different events that happen in the system. Outline how the system will react to those events. If you have a lot of events, try and group them into domains. If you can, define coarse-grained events connecting the domains. If a command, event, or reaction is not obvious to everyone, then add some examples. You can use the guide on event storming . Components : Make a C4 context diagram showing the actors and their activities interacting with the system. Make a C4 component diagram of the key components that make up the system so that all the different events reach a component. Add the components needed to make those other components work. Give them a clear name. Add a description if it's not obvious to everyone. Keep adding components until all the important components are sketched out. If you have a lot of components, group them into stacks of closely related components and make a C4 container diagram. If you have a lot of stacks, group them together into several distinct systems and make a C4 system landscape diagram. If it is important to decide now what technology to use for some of the components then write the technology used under the name. You can use the guide on whiteboarding C4 . Models : Draw circles for the main types that make up the main events. Add links between those main types as arrows and label the kind of link. If a type or link is not obvious to everyone then add some example facts. Add additional important facts about each type that needs to be in the software system using additional facts and links. Keep adding facts until enough of the types are sketched out that it is clear enough what all the events look like. You can use the guide on whiteboarding facts . Some advice while working through this order: Focus on capturing the most important design decisions. It is not important to be complete or have all the details. Try to go fast through each step. When you start slowing down during one of these steps, just move to the next one. During a later step you may discover other important information on previous steps, so go back and add it. If it seems like your group disagrees about a particular detail, slow down a bit. First figure out what the disagreement is. Write down a question. Then have a brief discussion. If consent on an answer is not quickly found, capture it as a topic to detail later. If you use ADRs or RFDs , this may be a good topic for such a document.","title":"Caseum whiteboarding step by step"},{"location":"guides/stages.html#focusing-in-on-specific-concerns","text":"Even though Caseum has 6 different views there can be yet other concerns that need more focus. For example, you may want to review the designs for security check the designs for consistency with some standard analyze the designs for quality attributes (non-functional requirements) analyze the designs for technology/platform choices analyze the designs for lower-level/infrastructure needs analyze the designs for architecture characteristics like cohesion or modularity perform an AWS well-architected review or another similar structured design review process For most of these reviews you do not need to complete the Models view. You do need the Components view, and to have a good Components view you should have the other views to some level of detail as well. To do so, draw the designs as you otherwise would. Then do an additional round to annotate the whiteboards based on those other issues. During the review write the issues on notes on the board, but do not immediately try to solve the issues. After you capture all the issues, prioritize them. Discuss only the important ones in more detail, and only as much as time allows.","title":"Focusing in on specific concerns"},{"location":"guides/stages.html#iterating-during-stage-1","text":"After you have whiteboarded initial versions of all the views, stop designing and implement some parts of the system. During implementation, you will learn a lot more which will inform your next iteration of the architecture. After you have implemented some software, make sure to test it, ideally by getting an initial production system in the hands of end users. When you do this you will learn a lot more. After your first iteration, evaluate whether your implementation is very different from your architecture. If the designs mostly match your results, and you all sort-of know the next steps to take to implement the next iteration, you may not need to do more design yet. During Caseum stage 1, do not worry too much about capturing the architecture permanently. There is a lot of value in just wiping (some of) the whiteboards and redrawing the design. Each time you redraw a picture you are likely to focus in more on what is important, leaving out the details that don't need to be in the picture. Each time you do this is an opportunity to discuss the design further and create a better shared understanding of what to do. It is also an opportunity to practice drawing and designing. This may sound inefficient, but it is very effective. Try it!","title":"Iterating during stage 1"},{"location":"guides/stages.html#time-budget-for-architecture","text":"Experienced teams that have clear user goals & needs, and have built similar systems before, using similar technology, may only need to spend only about 5% of their time creating and maintaining their design, i.e. about half a day at the beginning of a two-week sprint. Sometimes only a few of the people on the team need to do the design and the rest of the team can implement it. If the team has less experience, the user needs are less clear, the system architecture is very new, or the implementation technology is new, it can be worthwhile to spend more time on architecture and design, up to perhaps about 20% of all the time available, or about 2 afternoons a week. If you've spent more than a day a week doing architecture work, and this is not enough to know what to build during the rest of the week, spend some more time! This is one good indicator to start capturing designs more carefully - you may need to move to stage 2.","title":"Time budget for architecture"},{"location":"guides/stages.html#stage-2-digital-diagrams-and-decision-records","text":"During stage 2, you may still use whiteboards sometimes, but you also create and maintain a digital version of your designs. Some of the Caseum views work best as text documents. Caseum recommends Markdown templates for text documents and provides templates. Other Caseum views work best as visual diagrams. Caseum recommends draw.io for diagrams and provides templates and libraries.","title":"Stage 2: digital diagrams and decision records"},{"location":"guides/stages.html#actively-try-to-avoid-stage-2","text":"You want to stay in stage 1 if you can. Do not start immediately with step 2, for most new projects maintaining a set of digital diagrams is too much structure too quickly. At best doing all that work will slow you down. What happens more often is that you stop maintaining or improving your design, and the designs grow stale, no longer matching the software system that is being built. It is better to have up-to-date designs in medium detail on a whiteboard, than to have out-of-date designs being ignored on a wiki. On the other hand if you do find yourself redrawing the same picture a lot, or explaining the same concepts over and over again, then it is time to move from phase 1 to phase 2. There's other times when your team is usually fine with whiteboarding, but you need some high quality digital artifacts for some other reason (like an important presentation or a compliance audit). If that's the case, by all means produce the digital diagrams. But after the event, throw the files away! Ok, so perhaps you won't actually throw the diagrams away, fine. It's ok to print them out and stick them on your whiteboards. But what you should not do is start investing the effort to keep the fancy digital pictures up-to-date if you have no real need for them.","title":"Actively try to avoid stage 2"},{"location":"guides/stages.html#make-digital-versions-of-your-stage-1-views","text":"Your first step is to digitize everything. As you switch to a digital form, it is natural to be more precise and add more detail. Take the time to get the detail right. Usually that involves looking at the actual software system, so you don't fill in the detail based on your memory but based on the current reality. After you complete the first version of the digital views, review them. You may see things you want to change or improve in the system. Make a list, prioritize it, and perhaps plan to make the improvements.","title":"Make digital versions of your stage 1 views"},{"location":"guides/stages.html#caseum-digital-designs-step-by-step","text":"Actors : fill out a role description for each of your actors. You can use the role template . Stories : break down all your epics and activities into clear user stories. You can use the story template . Events : group your events by domain, if you did not do so yet. Give the domains clear names. create a description for each event. You can use the event template . Components : Create digital versions of all your existing C4 diagrams. Make sure all your actor roles are in the C4 context diagram. Make sure all your event domains are in the C4 diagrams. Create the C4 container diagram if you didn't have one yet. You can use the C4 template . Models : Do not directly create digital versions of your model diagrams. Instead, create your model diagrams based on the model definitions in your software systems (like your domain model or your SQL database definition scripts). Object-oriented or table-oriented modeling is more common than the fact-based modeling that Caseum recommends. You can read why fact-based modeling is great and decide to try it, or, you can use a modeling approach you already know. If you decide to use fact-based modeling, you can use the tlm template . UI : Maintaining digital UI designs is relatively a lot of effort that may not be worth it for you just for your architecture. If you are using a modern design tool like Figma already, you can use those designs instead. If you do not have such digital designs, you can use the UI template to make digital wireframes. You can also choose to maintain your UI designs on paper or on whiteboards while you digitize the other views.","title":"Caseum digital designs step by step"},{"location":"guides/stages.html#keep-more-detailed-records","text":"See the guide on keeping records . During step 1 you may have not kept detailed records. If so, during step 2 it is worth to start doing so. This is also a good time to consider the use of ADRs or RFDs.","title":"Keep more detailed records"},{"location":"guides/stages.html#iterating-during-step-2","text":"The more architecture views you have to maintain, the more useful it becomes to work on them a little bit regularly. If you only do a \"big bang\" architecture update every few months, there are long periods when your architecture is not so useful since it is too out-of-date to use. You could make updating the diagrams part of your definition-of-ready or your definition-of-done . Alternatively you could update the diagrams periodically, like at the beginning or end of a 2-week sprint.","title":"Iterating during step 2"},{"location":"guides/stages.html#time-budget-for-architecture_1","text":"Creating the initial digital versions of all the architecture views can be a significant one-off investment, perhaps up to a couple of weeks of effort if you managed to stay in stage 1 for as long as is recommended. After that initial investment, maintaining the digital views will also take some time on an ongoing basis. It shouldn't take more than about 20% of your time, and 10% would be better. If you find you do not have time for maintaining the diagrams, as a first step, clearly label the diagrams out-of-date. If the lack of up-to-date diagrams starts to cause you issues, then decide what to do. A good approach may be to only maintain the higher-level designs. Because those may change less frequently, this will be less effort. If you have many stories, events, components, or models, it may become more efficient to maintain them as code instead of as visual diagrams. That efficiency is the main reason to switch to Caseum stage 3.","title":"Time budget for architecture"},{"location":"guides/stages.html#handling-non-functional-requirements","text":"Many software architectures focus too much on interesting technical requirements and as a result systems become more rigid and complex than needed. To help combat this, Caseum focuses on working iteratively, keeping users and their needs in mind throughout the design process. However, for larger systems the non-functional requirements may become relatively more and more challenging to meet. Such needs are often not easy to visualize either. Instead, consider keeping more detailed records such as Architecture Decision Records (ADRs) or Requests For Discussion (RFDs) that explain how the non-functional requirements are being met.","title":"Handling non-functional requirements"},{"location":"guides/stages.html#stage-3-models-as-code-and-executable-specifications","text":"During stage 3 you define and maintain your Caseum architecture not using informal visuals and text documents, but with structured models as code and with executable specifications. You may generate some parts of your software from those models, or generate some of those models from your software.","title":"Stage 3: models as code and executable specifications"},{"location":"guides/stages.html#actively-try-to-avoid-stage-3","text":"Many engineers like the idea of models-as-code in theory. It appeals to them because they like coding, so coding the architecture also makes sense. There is also a promise of higher consistency. But such a technical approach can have serious downsides too: Requiring coding skills to work on the architecture, excluding some team members Rigid inflexible technical tools making it hard to flexibly express the architecture of the system in the most clear way Spending effort on dealing with technical tools and frameworks instead of communicating design decisions and building working software The larger and more complex a software system, the more likely there is value in adopting models as code. As a rule of thumb, it makes sense to start to evaluate using such tools when you have one system with over 50 components, over 100 models, and/or over 50 people working on it. Note that if you created a great software design, you can end up with many independent small systems maintained by small teams that have limited interaction. In that case, even for very large software landscapes, you still do not ever need stage 3!","title":"Actively try to avoid stage 3"},{"location":"guides/stages.html#experiment","text":"Rather than just switch from stage 2 to stage 3, do some experiments. Create some initial prototype versions of structured models and specifications. Measure how much time it takes to do so. Then maintain those prototypes for some period (perhaps 3 2-week sprints) and see how much time that takes. Evaluate whether you save time compared to maintaining the visual diagrams. If so, great! Otherwise, are there enough other benefits?","title":"Experiment!"},{"location":"guides/stages.html#caseum-models-as-code-step-by-step","text":"Stories : Start writing your stories in Gherkin format. You can consider using BDD and automate testing using the Gherkin stories, which is a great benefit of Gherkin, which is why Stories are a good view to start Caseum stage 3 with. You can use the Gherkin coding guide . Components : C4 has a great textual format in Structurizr that is worth using if you have a lot of components. You can use the C4 coding guide . Models : If you use advanced fact-based modeling, there are good bidirectional mappings between software systems and textual specifications, and you should consider them. For example, if you adopted TLM, you can use the TLM coding guide . On the other hand, if you use UML or other object-oriented modeling techniques, do not use automated bidirectional mapping tools, because they produce low-quality code. In this case it is better to work \"code first\": write source code and then generate the model definitions from your code. Events : You can consider using a formal standard for defining and maintaining event definitions. If you have a lot of system-to-system events, you may already be using detailed technical specifications for the APIs, like Swagger for REST APIs or Avro for messaging systems. If so, there is little value in codifying the event view separately. Otherwise, you can use the AsyncAPI coding guide . Actors : There's no executable specification for actors. Maintain the role descriptions as text, like in phase 2. UI : There's no executable specification for UI. If you have a large team working on a large software system that includes UI, then you probably have dedicated UI designers. Let them maintain the UI views and link to it from your architecture documentation.","title":"Caseum models as code step by step"},{"location":"guides/stages.html#beyond-stage-3","text":"For very large systems of systems you may need to go beyond Caseum.","title":"Beyond stage 3"},{"location":"guides/stages.html#platforms","text":"If you have many developer teams you may consider a platform team that focuses on providing a platform layer to the other developer teams. See the guide on platforms for how to use Caseum in that situation.","title":"Platforms"},{"location":"guides/stages.html#formal-enterprise-standards","text":"If you are building very large systems, you may consider a more formal architecture approach. Do not use Caseum to design space shuttles or nuclear power plants.","title":"Formal (enterprise) standards"},{"location":"guides/whiteboarding.html","text":"Whiteboarding guide The goal of whiteboarding is a dialogue after which everyone has a common understanding of the software architecture, not to draw the best pictures. It helps to be serious about whiteboarding. Prepare your whiteboarding sessions, practice your skills. Preparing for whiteboarding Like any activity whiteboarding sessions go better when you prepare for them well. So, prepare! Plan to capture your whiteboard outputs Reserve time at the end of a whiteboarding session to immediately capture all the content you produced in a permanent form and record it . Taking photos with your cell phone and uploading them works well. There are great free mobile apps that help process whiteboard pictures. Try Microsoft Lens ( Android , iOS ) or Adobe Scan ( Android , iOS ). Try Post-It ( Android , iOS ) if you have a whiteboard full of post-it notes. Have such apps on your phone before the session. There are also great mobile apps for keeping digital records. If you use Slack, have the Slack app on your phone. If you use SharePoint, have the OneDrive app on your phone. Log into the apps beforehand and try uploading some pictures with them. Have lots of good materials It is great to have lots of whiteboards (7 is a good number). Even better is a big room where all the walls are whiteboards. On a budget, you can get whiteboard stickers to put on walls or windows. Have enough dry-erase markers in multiple colors (black, blue, green, red), several times more than the number of participants. Have several dry-erase wipers. Have dry-wipe cloth plus whiteboard cleaning spray to fully clean the whiteboards. Cheap cloths often work better than whiteboard eraser blocks. Have enough decent quality sticky notes. The adhesive on old or cheap sticky notes gets worse and then the notes may come down off the board. Have multiple colors (for event storming : orange, purple, blue, green). Get high-quality materials. Practicing whiteboarding Drawing is a skill you get better at through practice. So, practice! Get comfortable writing on whiteboards Practice your writing on a whiteboard: Try to write more slowly, drawing nice letters instead of scribbling ugly ones. Try to write in a straight line. Try to write vertically. Try to write larger and smaller letters. Try to estimate how many letters you can fit in an area. Draw smaller and bigger boxes and try to write certain words in them. Evaluate your own writing by looking at the board at a distance. Then wipe it out and do better. If there are certain letters you can't write well, practice just those letters. Your handwriting does not need to be pretty, but it should be readable. Get comfortable drawing on whiteboards Practice simple drawing on a whiteboard: draw lots of rectangles of different sizes. draw lots of squares of different sizes. draw lots of straight lines of every angle. draw lots of ovals and circles. draw simple symbols for people. You can find a lot of specific drawing exercises online, but you don't need to learn creative drawing. Just do a lot of drawing and actively try to do a good job at it and you will improve. Draw to take photos Practice whiteboarding to capture the result: make a simple diagram on a whiteboard with boxes, lines, and text take a photo of the diagram with your phone look at the photo see what does and does not look good in the photo, pick one thing to improve wipe the drawing and try to make the same drawing again take another photo and see if the result is better rinse, repeat When you plan to take a photo of a whiteboard later you will often make a nicer drawing. Draw with colors Practice whiteboarding with colors: study the Caseum color scheme and try to make drawings on the whiteboard in the same or a similar color scheme practice keeping multiple markers in your hands and switching between them as you draw Once you are used to drawing with multiple colors it will help make the output of your brainstorming sessions look better. Talking through designs together The whiteboard is a tool you use to make a design. The design is a tool you use to communicate how to make software. Effective communication is more important than the picture that ends up on the whiteboard. Start with an empty board and go slowly Just like a PowerPoint slide with 20 bullets is overwhelming, a huge whiteboard filled with 20 different boxes and lines between them is overwhelming too. When sharing a design on a whiteboard, start with an empty whiteboard, and take the time to explain each element as you draw it on the board. Make sure your listeners are still following before drawing another box or another line. Go slow, pause, be open for questions and suggestions. Drawing together: blue pen, green pen, red pen, no pen When designing together, someone should start and draw something . Drawing the first concept on a blank canvas can be a bit intimidating for some. It is nice to have someone that goes first. Even if the first idea is not fully fledged, at least we got started. This might be someone using a blue pen. Others may not start the concept, but once something is on the board they are very good at saying \"yes, and...\" to add to the initial idea to expand it and make it better. This might be someone using a green pen. Still others are very comfortable saying \"no, because...\" to reduce an idea to the important essence or to challenge the group to come up with a better alternative to the initial idea. This might be someone using a red pen. Finally, there are those that may not do any of the drawing themselves, but they can ask the group good open \"what about ...\" questions to move the design forward. This person doesn't need a pen! To draw a good design together as a group, all of these contributions are needed. It is useful to get good at each style of contribution, and to know when which contribution is needed. It can be a good exercise for people in a team to deliberately take one of these roles, even if they would normally take a different one. You can also rotate between these roles in a way similar to pair programming or mob programming . Alternatives to whiteboards No whiteboard? No problem! Well, actually, a bit of a problem. Can't you go and buy a bunch of whiteboards? Digital whiteboards are worse for communication If you have a fully remote team using physical whiteboards may be impractical. In that case consider drawing on paper and sharing the designs using video conference software. You can also use online digital whiteboard software like excalidraw . Be careful of switching to a fancy diagramming or modeling tool just because you are working remotely! If you have the option, then physical whiteboarding is more effective because the communication is better. In a hybrid team that meets in an office one day a week, you could use a couple of hours of such a day for Caseum-style whiteboarding, then take some whiteboard photos home with you for the rest of the week. On a fully remote team you can also skip directly to the next stage and work with digital files. Blackboards There's nothing about architecture that requires a whiteboard instead of a blackboard. A lecture theatre with lots of large black boards also works great for Caseum. Having only one or two small black boards does not work as well, though: you need a lot of drawing space. Brown paper instead of a whiteboard If you only have 1 or 2 whiteboards, whiteboard stickers are too expensive, or you cannot get them to stick to your walls, you can use a combination of cheap brown paper you tape to a wall, plus sticky notes that you put on the paper. Such brownpaper sessions can sometimes work well, especially for work closer to requirements than to design, like when using event storming . Compared to whiteboards, brownpaper: supports more detail (if you write small on normal-size sticky notes) is cheaper to scale up for very large groups makes it easier to move things around (moving a sticky vs redrawing a box) focuses more on things (written on stickies) than the links between them (lines drawn between stickies) focuses more on words (written on stickies) than on visuals (shapes drawn by hand) This last point is why brownpaper sessions don't work as well for ui design .","title":"Whiteboarding architecture"},{"location":"guides/whiteboarding.html#whiteboarding-guide","text":"The goal of whiteboarding is a dialogue after which everyone has a common understanding of the software architecture, not to draw the best pictures. It helps to be serious about whiteboarding. Prepare your whiteboarding sessions, practice your skills.","title":"Whiteboarding guide"},{"location":"guides/whiteboarding.html#preparing-for-whiteboarding","text":"Like any activity whiteboarding sessions go better when you prepare for them well. So, prepare!","title":"Preparing for whiteboarding"},{"location":"guides/whiteboarding.html#plan-to-capture-your-whiteboard-outputs","text":"Reserve time at the end of a whiteboarding session to immediately capture all the content you produced in a permanent form and record it . Taking photos with your cell phone and uploading them works well. There are great free mobile apps that help process whiteboard pictures. Try Microsoft Lens ( Android , iOS ) or Adobe Scan ( Android , iOS ). Try Post-It ( Android , iOS ) if you have a whiteboard full of post-it notes. Have such apps on your phone before the session. There are also great mobile apps for keeping digital records. If you use Slack, have the Slack app on your phone. If you use SharePoint, have the OneDrive app on your phone. Log into the apps beforehand and try uploading some pictures with them.","title":"Plan to capture your whiteboard outputs"},{"location":"guides/whiteboarding.html#have-lots-of-good-materials","text":"It is great to have lots of whiteboards (7 is a good number). Even better is a big room where all the walls are whiteboards. On a budget, you can get whiteboard stickers to put on walls or windows. Have enough dry-erase markers in multiple colors (black, blue, green, red), several times more than the number of participants. Have several dry-erase wipers. Have dry-wipe cloth plus whiteboard cleaning spray to fully clean the whiteboards. Cheap cloths often work better than whiteboard eraser blocks. Have enough decent quality sticky notes. The adhesive on old or cheap sticky notes gets worse and then the notes may come down off the board. Have multiple colors (for event storming : orange, purple, blue, green). Get high-quality materials.","title":"Have lots of good materials"},{"location":"guides/whiteboarding.html#practicing-whiteboarding","text":"Drawing is a skill you get better at through practice. So, practice!","title":"Practicing whiteboarding"},{"location":"guides/whiteboarding.html#get-comfortable-writing-on-whiteboards","text":"Practice your writing on a whiteboard: Try to write more slowly, drawing nice letters instead of scribbling ugly ones. Try to write in a straight line. Try to write vertically. Try to write larger and smaller letters. Try to estimate how many letters you can fit in an area. Draw smaller and bigger boxes and try to write certain words in them. Evaluate your own writing by looking at the board at a distance. Then wipe it out and do better. If there are certain letters you can't write well, practice just those letters. Your handwriting does not need to be pretty, but it should be readable.","title":"Get comfortable writing on whiteboards"},{"location":"guides/whiteboarding.html#get-comfortable-drawing-on-whiteboards","text":"Practice simple drawing on a whiteboard: draw lots of rectangles of different sizes. draw lots of squares of different sizes. draw lots of straight lines of every angle. draw lots of ovals and circles. draw simple symbols for people. You can find a lot of specific drawing exercises online, but you don't need to learn creative drawing. Just do a lot of drawing and actively try to do a good job at it and you will improve.","title":"Get comfortable drawing on whiteboards"},{"location":"guides/whiteboarding.html#draw-to-take-photos","text":"Practice whiteboarding to capture the result: make a simple diagram on a whiteboard with boxes, lines, and text take a photo of the diagram with your phone look at the photo see what does and does not look good in the photo, pick one thing to improve wipe the drawing and try to make the same drawing again take another photo and see if the result is better rinse, repeat When you plan to take a photo of a whiteboard later you will often make a nicer drawing.","title":"Draw to take photos"},{"location":"guides/whiteboarding.html#draw-with-colors","text":"Practice whiteboarding with colors: study the Caseum color scheme and try to make drawings on the whiteboard in the same or a similar color scheme practice keeping multiple markers in your hands and switching between them as you draw Once you are used to drawing with multiple colors it will help make the output of your brainstorming sessions look better.","title":"Draw with colors"},{"location":"guides/whiteboarding.html#talking-through-designs-together","text":"The whiteboard is a tool you use to make a design. The design is a tool you use to communicate how to make software. Effective communication is more important than the picture that ends up on the whiteboard.","title":"Talking through designs together"},{"location":"guides/whiteboarding.html#start-with-an-empty-board-and-go-slowly","text":"Just like a PowerPoint slide with 20 bullets is overwhelming, a huge whiteboard filled with 20 different boxes and lines between them is overwhelming too. When sharing a design on a whiteboard, start with an empty whiteboard, and take the time to explain each element as you draw it on the board. Make sure your listeners are still following before drawing another box or another line. Go slow, pause, be open for questions and suggestions.","title":"Start with an empty board and go slowly"},{"location":"guides/whiteboarding.html#drawing-together-blue-pen-green-pen-red-pen-no-pen","text":"When designing together, someone should start and draw something . Drawing the first concept on a blank canvas can be a bit intimidating for some. It is nice to have someone that goes first. Even if the first idea is not fully fledged, at least we got started. This might be someone using a blue pen. Others may not start the concept, but once something is on the board they are very good at saying \"yes, and...\" to add to the initial idea to expand it and make it better. This might be someone using a green pen. Still others are very comfortable saying \"no, because...\" to reduce an idea to the important essence or to challenge the group to come up with a better alternative to the initial idea. This might be someone using a red pen. Finally, there are those that may not do any of the drawing themselves, but they can ask the group good open \"what about ...\" questions to move the design forward. This person doesn't need a pen! To draw a good design together as a group, all of these contributions are needed. It is useful to get good at each style of contribution, and to know when which contribution is needed. It can be a good exercise for people in a team to deliberately take one of these roles, even if they would normally take a different one. You can also rotate between these roles in a way similar to pair programming or mob programming .","title":"Drawing together: blue pen, green pen, red pen, no pen"},{"location":"guides/whiteboarding.html#alternatives-to-whiteboards","text":"No whiteboard? No problem! Well, actually, a bit of a problem. Can't you go and buy a bunch of whiteboards?","title":"Alternatives to whiteboards"},{"location":"guides/whiteboarding.html#digital-whiteboards-are-worse-for-communication","text":"If you have a fully remote team using physical whiteboards may be impractical. In that case consider drawing on paper and sharing the designs using video conference software. You can also use online digital whiteboard software like excalidraw . Be careful of switching to a fancy diagramming or modeling tool just because you are working remotely! If you have the option, then physical whiteboarding is more effective because the communication is better. In a hybrid team that meets in an office one day a week, you could use a couple of hours of such a day for Caseum-style whiteboarding, then take some whiteboard photos home with you for the rest of the week. On a fully remote team you can also skip directly to the next stage and work with digital files.","title":"Digital whiteboards are worse for communication"},{"location":"guides/whiteboarding.html#blackboards","text":"There's nothing about architecture that requires a whiteboard instead of a blackboard. A lecture theatre with lots of large black boards also works great for Caseum. Having only one or two small black boards does not work as well, though: you need a lot of drawing space.","title":"Blackboards"},{"location":"guides/whiteboarding.html#brown-paper-instead-of-a-whiteboard","text":"If you only have 1 or 2 whiteboards, whiteboard stickers are too expensive, or you cannot get them to stick to your walls, you can use a combination of cheap brown paper you tape to a wall, plus sticky notes that you put on the paper. Such brownpaper sessions can sometimes work well, especially for work closer to requirements than to design, like when using event storming . Compared to whiteboards, brownpaper: supports more detail (if you write small on normal-size sticky notes) is cheaper to scale up for very large groups makes it easier to move things around (moving a sticky vs redrawing a box) focuses more on things (written on stickies) than the links between them (lines drawn between stickies) focuses more on words (written on stickies) than on visuals (shapes drawn by hand) This last point is why brownpaper sessions don't work as well for ui design .","title":"Brown paper instead of a whiteboard"},{"location":"models/fact-modeling.html","text":"Fact-Based Modeling Fact-oriented descriptions of information models are more stable, durable, and expressive than using UML or ER. They are easier to understand for non-technical stakeholders. Why doesn't everyone know about FBM? Fact-Based Modeling is to UML as Lisp is to Java: older, more powerful, and sadly less well-known and used. But while Lisp is hard to learn, FBM is easy! The main reason FBM isn't more popular is that the software industry has spent decades trying to make model-driven software development work (whether using CASE tools, MDA, or no-code platforms), focusing on modeling tools and languages that are easy to translate to object-oriented or procedural software. Why should I use FBM? Because it works really well! The original ORM whitepaper remains the best practical description of the many advantages of fact-based modeling. Why should I use FBM with Caseum? Caseum is quite a practical architecture tool for building software. The main purpose of architecture when making software is to help you to design and to think about the software. Caseum picks the best available tools for thinking, and modeling using facts is a great way to think! What is a fact? A fact is a piece of information that is true about the business domain. Facts are the building blocks of information models. What is fact-based modeling? Fact-based modeling is a modeling technique that focuses on facts and their relationships. It is a family of techniques that includes Object-Role Modeling (ORM) , Type-Link Modeling (TLM) , NIAM , and FCO-IM . Can I use Caseum without using fact-based modeling? Sure! For bigger systems, simply replace TLM or ORM or another fact-based approach with another structured way to model the information domain for your software. You could use ER-style diagrams or UML class diagrams. For smaller systems, just use informal boxes-and-lines-and-sticky-notes whiteboarding in any way you like.","title":"Fact-based modeling"},{"location":"models/fact-modeling.html#fact-based-modeling","text":"Fact-oriented descriptions of information models are more stable, durable, and expressive than using UML or ER. They are easier to understand for non-technical stakeholders.","title":"Fact-Based Modeling"},{"location":"models/fact-modeling.html#why-doesnt-everyone-know-about-fbm","text":"Fact-Based Modeling is to UML as Lisp is to Java: older, more powerful, and sadly less well-known and used. But while Lisp is hard to learn, FBM is easy! The main reason FBM isn't more popular is that the software industry has spent decades trying to make model-driven software development work (whether using CASE tools, MDA, or no-code platforms), focusing on modeling tools and languages that are easy to translate to object-oriented or procedural software.","title":"Why doesn't everyone know about FBM?"},{"location":"models/fact-modeling.html#why-should-i-use-fbm","text":"Because it works really well! The original ORM whitepaper remains the best practical description of the many advantages of fact-based modeling.","title":"Why should I use FBM?"},{"location":"models/fact-modeling.html#why-should-i-use-fbm-with-caseum","text":"Caseum is quite a practical architecture tool for building software. The main purpose of architecture when making software is to help you to design and to think about the software. Caseum picks the best available tools for thinking, and modeling using facts is a great way to think!","title":"Why should I use FBM with Caseum?"},{"location":"models/fact-modeling.html#what-is-a-fact","text":"A fact is a piece of information that is true about the business domain. Facts are the building blocks of information models.","title":"What is a fact?"},{"location":"models/fact-modeling.html#what-is-fact-based-modeling","text":"Fact-based modeling is a modeling technique that focuses on facts and their relationships. It is a family of techniques that includes Object-Role Modeling (ORM) , Type-Link Modeling (TLM) , NIAM , and FCO-IM .","title":"What is fact-based modeling?"},{"location":"models/fact-modeling.html#can-i-use-caseum-without-using-fact-based-modeling","text":"Sure! For bigger systems, simply replace TLM or ORM or another fact-based approach with another structured way to model the information domain for your software. You could use ER-style diagrams or UML class diagrams. For smaller systems, just use informal boxes-and-lines-and-sticky-notes whiteboarding in any way you like.","title":"Can I use Caseum without using fact-based modeling?"},{"location":"models/fact-whiteboarding.html","text":"Whiteboarding Models Draw the key facts about the concepts of your business domain on the whiteboard. Focus on types and the links between them, not the underlying structure. Draw just the facts A fact is a piece of information that is true about the business domain. Draw only types that are known to exist in the domain. Draw only relationships that are known to exist in the domain. Draw only types and relationships in the domain that the software needs to know about. Draw circles instead of boxes The dominance of ER and UML modeling techniques in creating software designs is a minor tragedy. By drawing boxes of entities (whether tables or classes) and then putting the properties of those entities inside the boxes, you think about the structure of the data too much and too early. To avoid this trap, simply draw circles for each type (entity, class, concept) instead. To add a property, relationship, or other detail about the type, draw another circle, and link the circles with a line. By working this way, you do not introduce a hierarchy of types vs properties, and you can iterate on the design on the whiteboard and discover the eventual hierarchy as you go. Draw crow's feet for one-to-many or many-to-many relationships To show that a link between two types is a one-to-many or many-to-many relationship, draw a crow's foot on the end of the line. Draw arrows for inheritance If a certain type is a specialization of another type, draw an open-head arrow from the specialized type to the general type. Don't use inheritance unless you need it. Draw the same concept multiple times If you are drawing a large model, avoid drawing super-long lines that are hard to trace. Instead, you can draw the same type a couple of times in different places on the whiteboard so that you can show all its relationships. Write the primary identifier of a type inside the circle If a type has a single primary identifier in the business domain, write it inside the circle, right after the type name, in brackets. For example, \"Bank Account (IBAN)\". Avoid specifying all facts on the whiteboard The whiteboard is a tool for thinking. It is not necessary to specify all facts on the whiteboard. Instead, focus on the facts that are most important to the software design. While you can draw TLM or ORM diagrams on a whiteboard, the addition of formal syntax and semantics makes it harder to contribute for those not trained in the technique. It is often better to stick to simpler diagrams and focus on the conversation of what the key facts are and how the software should support such facts. Add examples of facts A few pieces of concrete example data help a lot to clarify the model. Especially for more complex domain concepts, add some concrete examples, usually as a table of sample data.","title":"Fact whiteboarding"},{"location":"models/fact-whiteboarding.html#whiteboarding-models","text":"Draw the key facts about the concepts of your business domain on the whiteboard. Focus on types and the links between them, not the underlying structure.","title":"Whiteboarding Models"},{"location":"models/fact-whiteboarding.html#draw-just-the-facts","text":"A fact is a piece of information that is true about the business domain. Draw only types that are known to exist in the domain. Draw only relationships that are known to exist in the domain. Draw only types and relationships in the domain that the software needs to know about.","title":"Draw just the facts"},{"location":"models/fact-whiteboarding.html#draw-circles-instead-of-boxes","text":"The dominance of ER and UML modeling techniques in creating software designs is a minor tragedy. By drawing boxes of entities (whether tables or classes) and then putting the properties of those entities inside the boxes, you think about the structure of the data too much and too early. To avoid this trap, simply draw circles for each type (entity, class, concept) instead. To add a property, relationship, or other detail about the type, draw another circle, and link the circles with a line. By working this way, you do not introduce a hierarchy of types vs properties, and you can iterate on the design on the whiteboard and discover the eventual hierarchy as you go.","title":"Draw circles instead of boxes"},{"location":"models/fact-whiteboarding.html#draw-crows-feet-for-one-to-many-or-many-to-many-relationships","text":"To show that a link between two types is a one-to-many or many-to-many relationship, draw a crow's foot on the end of the line.","title":"Draw crow's feet for one-to-many or many-to-many relationships"},{"location":"models/fact-whiteboarding.html#draw-arrows-for-inheritance","text":"If a certain type is a specialization of another type, draw an open-head arrow from the specialized type to the general type. Don't use inheritance unless you need it.","title":"Draw arrows for inheritance"},{"location":"models/fact-whiteboarding.html#draw-the-same-concept-multiple-times","text":"If you are drawing a large model, avoid drawing super-long lines that are hard to trace. Instead, you can draw the same type a couple of times in different places on the whiteboard so that you can show all its relationships.","title":"Draw the same concept multiple times"},{"location":"models/fact-whiteboarding.html#write-the-primary-identifier-of-a-type-inside-the-circle","text":"If a type has a single primary identifier in the business domain, write it inside the circle, right after the type name, in brackets. For example, \"Bank Account (IBAN)\".","title":"Write the primary identifier of a type inside the circle"},{"location":"models/fact-whiteboarding.html#avoid-specifying-all-facts-on-the-whiteboard","text":"The whiteboard is a tool for thinking. It is not necessary to specify all facts on the whiteboard. Instead, focus on the facts that are most important to the software design. While you can draw TLM or ORM diagrams on a whiteboard, the addition of formal syntax and semantics makes it harder to contribute for those not trained in the technique. It is often better to stick to simpler diagrams and focus on the conversation of what the key facts are and how the software should support such facts.","title":"Avoid specifying all facts on the whiteboard"},{"location":"models/fact-whiteboarding.html#add-examples-of-facts","text":"A few pieces of concrete example data help a lot to clarify the model. Especially for more complex domain concepts, add some concrete examples, usually as a table of sample data.","title":"Add examples of facts"},{"location":"models/tlm-code.html","text":"Describing Models using Type-Link Modeling and TLMD Fully and formally describe your model in code using TLMD. --- Person A Person is a \"being regarded as an individual\". A Person is identified by id which must be a URI. A Person has exactly one name which must be a Name. A Person has toggle coaches. A Person, the coachee, can have some coach which must be a Person, the coach. Examples: coachee/name | coach/name ================================ Michael Jackson | Diana Ross Peter Parker | Tony Stark Peter Parker | Aunt May Type-Link-Model includes a plain text modeling format, TLMD. TLMD is a great way to capture a model in a way that is both human-readable and machine-readable. Decent-looking visual diagrams can be generated automatically from TLMD. You can also generate XML Schema, JSON Schema, and other such artifacts from TLMD. Consider using ORM instead of TLMD ORM has a similar plain text modeling format, which is more powerful than TLMD. If you need all the power of ORM, use it instead. Why not UML or ER? See Fact-Based Modeling for a description of the advantages of fact-based modeling techniques over more well-known approaches such as UML class diagrams. Why not OWL (Web Ontology Language)? OWL is a powerful modeling technique for the semantic web . Because the semantic web uses the open-world assumption , it is hard to create high-performance software that natively uses its models. Only use OWL if your problem requires a web-scale solution.","title":"TLM models-as-code"},{"location":"models/tlm-code.html#describing-models-using-type-link-modeling-and-tlmd","text":"Fully and formally describe your model in code using TLMD. --- Person A Person is a \"being regarded as an individual\". A Person is identified by id which must be a URI. A Person has exactly one name which must be a Name. A Person has toggle coaches. A Person, the coachee, can have some coach which must be a Person, the coach. Examples: coachee/name | coach/name ================================ Michael Jackson | Diana Ross Peter Parker | Tony Stark Peter Parker | Aunt May Type-Link-Model includes a plain text modeling format, TLMD. TLMD is a great way to capture a model in a way that is both human-readable and machine-readable. Decent-looking visual diagrams can be generated automatically from TLMD. You can also generate XML Schema, JSON Schema, and other such artifacts from TLMD.","title":"Describing Models using Type-Link Modeling and TLMD"},{"location":"models/tlm-code.html#consider-using-orm-instead-of-tlmd","text":"ORM has a similar plain text modeling format, which is more powerful than TLMD. If you need all the power of ORM, use it instead.","title":"Consider using ORM instead of TLMD"},{"location":"models/tlm-code.html#why-not-uml-or-er","text":"See Fact-Based Modeling for a description of the advantages of fact-based modeling techniques over more well-known approaches such as UML class diagrams.","title":"Why not UML or ER?"},{"location":"models/tlm-code.html#why-not-owl-web-ontology-language","text":"OWL is a powerful modeling technique for the semantic web . Because the semantic web uses the open-world assumption , it is hard to create high-performance software that natively uses its models. Only use OWL if your problem requires a web-scale solution.","title":"Why not OWL (Web Ontology Language)?"},{"location":"models/tlm-template.html","text":"Describing Models using Type-Link Modeling and draw.io Draw the facts of the domain model using a formal syntax. Type-Link-Model (TLM) is a fact-based modeling technique inspired by but simpler than Object-Role Modeling (ORM) . Using a formal syntax and semantics based on types and the links between them, TLM allows capturing most domain models precisely. TLM provides draw.io stencils and examples that you can use with Caseum stage 2 . Consider ORM instead of TLM ORM is the work of scientist Terry Halpin who has written a seminal book on logical database design, Information Modeling and Relational Databases . ORM2 is a complete superset of modern UML class diagrams and allows clear expression of any relational model plus the associated business rules that you could capture using UML its Object Constraint Language (OCL). If you need such modeling rigor ORM is the only choice. But the vast majority of projects have simpler needs and so can make do with a small compatible subset of ORM that is easier to learn, which is what TLM provides. Consider other Fact-Based Modeling techniques Alternative fact-based modeling techniques include NIAM , and FCO-IM . Most such techniques were created to provide additional power and rigor beyond ORM so are most suited to advanced needs. Why not UML class diagrams or ER? See Fact-Based Modeling for a description of the advantages of fact-based modeling techniques over more well-known approaches such as UML class diagrams.","title":"TLM template"},{"location":"models/tlm-template.html#describing-models-using-type-link-modeling-and-drawio","text":"Draw the facts of the domain model using a formal syntax. Type-Link-Model (TLM) is a fact-based modeling technique inspired by but simpler than Object-Role Modeling (ORM) . Using a formal syntax and semantics based on types and the links between them, TLM allows capturing most domain models precisely. TLM provides draw.io stencils and examples that you can use with Caseum stage 2 .","title":"Describing Models using Type-Link Modeling and draw.io"},{"location":"models/tlm-template.html#consider-orm-instead-of-tlm","text":"ORM is the work of scientist Terry Halpin who has written a seminal book on logical database design, Information Modeling and Relational Databases . ORM2 is a complete superset of modern UML class diagrams and allows clear expression of any relational model plus the associated business rules that you could capture using UML its Object Constraint Language (OCL). If you need such modeling rigor ORM is the only choice. But the vast majority of projects have simpler needs and so can make do with a small compatible subset of ORM that is easier to learn, which is what TLM provides.","title":"Consider ORM instead of TLM"},{"location":"models/tlm-template.html#consider-other-fact-based-modeling-techniques","text":"Alternative fact-based modeling techniques include NIAM , and FCO-IM . Most such techniques were created to provide additional power and rigor beyond ORM so are most suited to advanced needs.","title":"Consider other Fact-Based Modeling techniques"},{"location":"models/tlm-template.html#why-not-uml-class-diagrams-or-er","text":"See Fact-Based Modeling for a description of the advantages of fact-based modeling techniques over more well-known approaches such as UML class diagrams.","title":"Why not UML class diagrams or ER?"},{"location":"stories/gherkin-code.html","text":"Behavior-Driven Development using Gherkin stories Use Gherkin to turn your user stories into executable specifications. Gherkin is a simple language for describing the behavior of software. It is used by Cucumber , SpecFlow , and other tools, Gherkin is used to turn user stories into executable specifications. When using Gherkin to capture stories as code, consider using VSCode with the Gherkin extension . If you use JetBrains IDEs, you can use the Gherkin plugin instead. Keep the Gherkin stories in the same repository as the code they describe. This makes it easier to keep the stories up to date as the code changes and to run them as continuous integration tests. You can also use Cucumber Studio for writing stories. Cucumber studio helps non-technical authors to create Gherkin stories, but it is relatively expensive for its limited feature set.","title":"Gherkin specs-as-code"},{"location":"stories/gherkin-code.html#behavior-driven-development-using-gherkin-stories","text":"Use Gherkin to turn your user stories into executable specifications. Gherkin is a simple language for describing the behavior of software. It is used by Cucumber , SpecFlow , and other tools, Gherkin is used to turn user stories into executable specifications. When using Gherkin to capture stories as code, consider using VSCode with the Gherkin extension . If you use JetBrains IDEs, you can use the Gherkin plugin instead. Keep the Gherkin stories in the same repository as the code they describe. This makes it easier to keep the stories up to date as the code changes and to run them as continuous integration tests. You can also use Cucumber Studio for writing stories. Cucumber studio helps non-technical authors to create Gherkin stories, but it is relatively expensive for its limited feature set.","title":"Behavior-Driven Development using Gherkin stories"},{"location":"stories/story-template.html","text":"Describing stories with Who/What/Why Use a simple but structured format for each story that describes Who/What/Why. When the details matter, also describe Given/When/Then. Story markdown template Caseum adopts the typical format of user stories common in many agile methods: ### {story title} * **As a** {actor role} * **I want** {goal of the story} * **so that** {reason of the story} When specific detail is important to the design you should add it, in the form of a scenario: #### Scenario: * **Given** {context} * (**And** {more context...}) * **When** {action} * (**And** {another action...}) * **Then** {expected result} * (**And** {another result...}) Story example Add vet to Pet Clinic As a pet clinic receptionist I want to add a new vet to the Pet Clinic so that appointments can be planned for this vet Scenario: Given I'm logged in to the Pet Clinic Admin When I select the Vet Admin And I select the Add Vet function When I submit details of a new Vet Then a new Vet should be added to the system Organizing stories When there are a few stories (20 or less) they can all be combined into a document. When there are more, combine them into one document per actor role. When that becomes unwieldy, create one document per story, with a folder or section per actor. When that becomes unwieldy (100 or more stories), consider switching to the next stage and start writing Gherkin code for acceptance tests. Stories to structure software development In agile software development it is common to implement the software one story at a time. While this way of working is of course compatible with Caseum, it is not required. If you decide to work this way, make sure to keep a complete catalog of all the stories! The catalog should include both the implemented and the not yet implemented stories. This full set of stories should be kept as documentation in order to make good decisions about the architecture.","title":"Story template"},{"location":"stories/story-template.html#describing-stories-with-whowhatwhy","text":"Use a simple but structured format for each story that describes Who/What/Why. When the details matter, also describe Given/When/Then.","title":"Describing stories with Who/What/Why"},{"location":"stories/story-template.html#story-markdown-template","text":"Caseum adopts the typical format of user stories common in many agile methods: ### {story title} * **As a** {actor role} * **I want** {goal of the story} * **so that** {reason of the story} When specific detail is important to the design you should add it, in the form of a scenario: #### Scenario: * **Given** {context} * (**And** {more context...}) * **When** {action} * (**And** {another action...}) * **Then** {expected result} * (**And** {another result...})","title":"Story markdown template"},{"location":"stories/story-template.html#story-example","text":"","title":"Story example"},{"location":"stories/story-template.html#add-vet-to-pet-clinic","text":"As a pet clinic receptionist I want to add a new vet to the Pet Clinic so that appointments can be planned for this vet","title":"Add vet to Pet Clinic"},{"location":"stories/story-template.html#scenario","text":"Given I'm logged in to the Pet Clinic Admin When I select the Vet Admin And I select the Add Vet function When I submit details of a new Vet Then a new Vet should be added to the system","title":"Scenario:"},{"location":"stories/story-template.html#organizing-stories","text":"When there are a few stories (20 or less) they can all be combined into a document. When there are more, combine them into one document per actor role. When that becomes unwieldy, create one document per story, with a folder or section per actor. When that becomes unwieldy (100 or more stories), consider switching to the next stage and start writing Gherkin code for acceptance tests.","title":"Organizing stories"},{"location":"stories/story-template.html#stories-to-structure-software-development","text":"In agile software development it is common to implement the software one story at a time. While this way of working is of course compatible with Caseum, it is not required. If you decide to work this way, make sure to keep a complete catalog of all the stories! The catalog should include both the implemented and the not yet implemented stories. This full set of stories should be kept as documentation in order to make good decisions about the architecture.","title":"Stories to structure software development"},{"location":"stories/story-whiteboarding.html","text":"Whiteboarding Stories Get enough coarse-grained epic stories on the whiteboard to inform the design. It is easy to write a lot of story details, but only do so if the details are really important to the design. Ideally the users and stakeholders of the system are actively involved while writing down the stories describing how they will use the system. If so, guide them to describe all the functionality of the system at a pretty high level. You can use any structure that captures well how people talk about the software systems. Talk through stories from the perspective of each actor's needs . Different actors may share some stories but have slightly different needs during such a story. Limit the level of detail if you can Sometimes, users or domain experts will insist on going into a lot of detail about a particular story because they consider those details particularly vital to the system. When this happens, capture the details using a Given/When/Then Gherkin-style story , but you do not need to do this for all stories. If it is difficult to group stories into coarse-grained epics, simply switch to event storming to capture multiple stories in a flow consisting of domain events, and return back to the story list later. Avoid setting priorities Teams used to using stories with backlogs in agile development processes may look to start prioritizing stories already. This is not needed yet: prioritization of development can happen more easily after the architecture has been defined using Caseum. This is more effective, because when the whole architecture is visible in different views it is often obvious some stories must go first. Storming stories It can be effective in bigger groups to split the story writing into small groups. There are many possibilities. For example, you may use a variant of the 1-2-4-All Liberating Structure : have everyone sit individually for up to 5 minutes writing stories on sticky notes. Ask them to consider each actor. add all the stories to the whiteboard grouped by actor. Take a moment to consider overlap, and have shared stories grouped with their main actor. divide the team into subgroups per actor. Have the subteams take 10 minutes to rewrite all the stories, combining and integrating the different inputs, and adding new ones. have subteams take two minutes each to describe the revised stories to the whole team.","title":"Story whiteboarding"},{"location":"stories/story-whiteboarding.html#whiteboarding-stories","text":"Get enough coarse-grained epic stories on the whiteboard to inform the design. It is easy to write a lot of story details, but only do so if the details are really important to the design. Ideally the users and stakeholders of the system are actively involved while writing down the stories describing how they will use the system. If so, guide them to describe all the functionality of the system at a pretty high level. You can use any structure that captures well how people talk about the software systems. Talk through stories from the perspective of each actor's needs . Different actors may share some stories but have slightly different needs during such a story.","title":"Whiteboarding Stories"},{"location":"stories/story-whiteboarding.html#limit-the-level-of-detail-if-you-can","text":"Sometimes, users or domain experts will insist on going into a lot of detail about a particular story because they consider those details particularly vital to the system. When this happens, capture the details using a Given/When/Then Gherkin-style story , but you do not need to do this for all stories. If it is difficult to group stories into coarse-grained epics, simply switch to event storming to capture multiple stories in a flow consisting of domain events, and return back to the story list later.","title":"Limit the level of detail if you can"},{"location":"stories/story-whiteboarding.html#avoid-setting-priorities","text":"Teams used to using stories with backlogs in agile development processes may look to start prioritizing stories already. This is not needed yet: prioritization of development can happen more easily after the architecture has been defined using Caseum. This is more effective, because when the whole architecture is visible in different views it is often obvious some stories must go first.","title":"Avoid setting priorities"},{"location":"stories/story-whiteboarding.html#storming-stories","text":"It can be effective in bigger groups to split the story writing into small groups. There are many possibilities. For example, you may use a variant of the 1-2-4-All Liberating Structure : have everyone sit individually for up to 5 minutes writing stories on sticky notes. Ask them to consider each actor. add all the stories to the whiteboard grouped by actor. Take a moment to consider overlap, and have shared stories grouped with their main actor. divide the team into subgroups per actor. Have the subteams take 10 minutes to rewrite all the stories, combining and integrating the different inputs, and adding new ones. have subteams take two minutes each to describe the revised stories to the whole team.","title":"Storming stories"},{"location":"ui/ui-template.html","text":"Creating UI designs with draw.io Caseum designs can include some UI design. Caseum UI designs focus on functionality. Caseum does not include high quality visuals. Designs are made with wireframes using a mockup visual style. Drawing tools: Caseum-Wireframe.xml : a draw.io custom shape library with simple mockup elements using the Caseum colors. User guide . wireframe.drawio : a draw.io stencil containing the elements in the custom shape library. Visually, Caseum UI designs look like this: Caseum UI designs may be implemented directly in software by developers with access to a design system. Or, the UI may be further designed in a high quality visual design tool like Figma .","title":"UI template"},{"location":"ui/ui-template.html#creating-ui-designs-with-drawio","text":"Caseum designs can include some UI design. Caseum UI designs focus on functionality. Caseum does not include high quality visuals. Designs are made with wireframes using a mockup visual style. Drawing tools: Caseum-Wireframe.xml : a draw.io custom shape library with simple mockup elements using the Caseum colors. User guide . wireframe.drawio : a draw.io stencil containing the elements in the custom shape library. Visually, Caseum UI designs look like this: Caseum UI designs may be implemented directly in software by developers with access to a design system. Or, the UI may be further designed in a high quality visual design tool like Figma .","title":"Creating UI designs with draw.io"},{"location":"ui/ui-whiteboarding.html","text":"Whiteboarding UI Use free-form whiteboarding to sketch the initial user interface. It is not important to have detailed button states, complete labels, or colors. Instead, focus on the overall layout and the flow of the user interface. By drawing UI and describing how it should work, you clarify the choices made in the other Caseum views. This is especially helpful for non-technical stakeholders. When you talk through the UI sketches, you will often find new requirements that require changes to the user stories, domain events, or models. There is a lot of good advice on UI and UX design that is also useful when sketching UI on the whiteboard. Caseum does not replicate that advice. Many architects are not good UI designers, and few UI designers are also architects. Recognize the differences in skill and plan for it. When possible, involve a skilled UI/UX designer early on in designing software.","title":"UI whiteboarding"},{"location":"ui/ui-whiteboarding.html#whiteboarding-ui","text":"Use free-form whiteboarding to sketch the initial user interface. It is not important to have detailed button states, complete labels, or colors. Instead, focus on the overall layout and the flow of the user interface. By drawing UI and describing how it should work, you clarify the choices made in the other Caseum views. This is especially helpful for non-technical stakeholders. When you talk through the UI sketches, you will often find new requirements that require changes to the user stories, domain events, or models. There is a lot of good advice on UI and UX design that is also useful when sketching UI on the whiteboard. Caseum does not replicate that advice. Many architects are not good UI designers, and few UI designers are also architects. Recognize the differences in skill and plan for it. When possible, involve a skilled UI/UX designer early on in designing software.","title":"Whiteboarding UI"}]}